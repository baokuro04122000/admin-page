/* tslint:disable */
/* eslint-disable */
/**
 * BT API document
 * This is a BT API document
 *
 * The version of the OpenAPI document: 1.0.1
 * Contact: baotrandinh100@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AnnouceSuccess
 */
export interface AnnouceSuccess {
    /**
     * 
     * @type {number}
     * @memberof AnnouceSuccess
     */
    'status'?: number;
    /**
     * 
     * @type {AnnouceSuccessData}
     * @memberof AnnouceSuccess
     */
    'data'?: AnnouceSuccessData;
}
/**
 * 
 * @export
 * @interface AnnouceSuccessData
 */
export interface AnnouceSuccessData {
    /**
     * 
     * @type {string}
     * @memberof AnnouceSuccessData
     */
    'message'?: string;
}
/**
 * API to save a list of photos to delete
 * @export
 * @interface DeleteImagesRequest
 */
export interface DeleteImagesRequest {
    /**
     * the field that it is unique
     * @type {string}
     * @memberof DeleteImagesRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeleteImagesRequest
     */
    'token'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteImagesRequest
     */
    'fileList'?: Array<string>;
}
/**
 * Error responses are sent when an error (e.g. unauthorized, bad request) occurred.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * the status of response.
     * @type {number}
     * @memberof ErrorResponse
     */
    'status'?: number;
    /**
     * 
     * @type {ErrorResponseErrors}
     * @memberof ErrorResponse
     */
    'errors'?: ErrorResponseErrors;
}
/**
 * 
 * @export
 * @interface ErrorResponseErrors
 */
export interface ErrorResponseErrors {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseErrors
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface ForgotPassword
 */
export interface ForgotPassword {
    /**
     * 
     * @type {string}
     * @memberof ForgotPassword
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ForgotPasswordRequest
 */
export interface ForgotPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordRequest
     */
    'email': string;
}
/**
 * some information that it relate the shop of seller
 * @export
 * @interface MetaSeller
 */
export interface MetaSeller {
    /**
     * 
     * @type {number}
     * @memberof MetaSeller
     */
    'totalSole'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaSeller
     */
    'totalProduct'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaSeller
     */
    'totalEvaluation'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaSeller
     */
    'ranking'?: number;
    /**
     * 
     * @type {string}
     * @memberof MetaSeller
     */
    'title'?: string;
}
/**
 * OTP got from your email
 * @export
 * @interface OTPRequest
 */
export interface OTPRequest {
    /**
     * 
     * @type {number}
     * @memberof OTPRequest
     */
    'otp': number;
}
/**
 * OTP got from your email
 * @export
 * @interface OTPRequestActive
 */
export interface OTPRequestActive {
    /**
     * 
     * @type {string}
     * @memberof OTPRequestActive
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof OTPRequestActive
     */
    'otp': number;
}
/**
 * 
 * @export
 * @interface OTPResponse
 */
export interface OTPResponse {
    /**
     * 
     * @type {OTPResponseData}
     * @memberof OTPResponse
     */
    'data'?: OTPResponseData;
}
/**
 * 
 * @export
 * @interface OTPResponseData
 */
export interface OTPResponseData {
    /**
     * 
     * @type {string}
     * @memberof OTPResponseData
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'password'?: string;
}
/**
 * Seller detail information
 * @export
 * @interface SellerDetail
 */
export interface SellerDetail {
    /**
     * 
     * @type {string}
     * @memberof SellerDetail
     */
    'id'?: string;
    /**
     * the brand of shop
     * @type {string}
     * @memberof SellerDetail
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerDetail
     */
    'slogan'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerDetail
     */
    'type'?: string;
    /**
     * 
     * @type {Array<MetaSeller>}
     * @memberof SellerDetail
     */
    'meta'?: Array<MetaSeller>;
    /**
     * to implement lock the account of seller
     * @type {boolean}
     * @memberof SellerDetail
     */
    'isDisable'?: boolean;
}
/**
 * the info of seller will send to server to create a seller account
 * @export
 * @interface SellerRegisterRequest
 */
export interface SellerRegisterRequest {
    /**
     * check role
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'fbLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'inLink'?: string;
    /**
     * name is unique
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'slogan': string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'phone': string;
    /**
     * 
     * @type {SellerRegisterRequestLogo}
     * @memberof SellerRegisterRequest
     */
    'logo'?: SellerRegisterRequestLogo;
    /**
     * It help the seller confirm the Genuine Store
     * @type {Array<SellerRegisterRequestProofInner>}
     * @memberof SellerRegisterRequest
     */
    'proof'?: Array<SellerRegisterRequestProofInner>;
}
/**
 * The logo of shop
 * @export
 * @interface SellerRegisterRequestLogo
 */
export interface SellerRegisterRequestLogo {
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequestLogo
     */
    'fileLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequestLogo
     */
    'fileId'?: string;
}
/**
 * 
 * @export
 * @interface SellerRegisterRequestProofInner
 */
export interface SellerRegisterRequestProofInner {
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequestProofInner
     */
    'fileLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequestProofInner
     */
    'fileId'?: string;
}
/**
 * 
 * @export
 * @interface UserCredentialResponse
 */
export interface UserCredentialResponse {
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {UserCredentialResponseData}
     * @memberof UserCredentialResponse
     */
    'data'?: UserCredentialResponseData;
}
/**
 * 
 * @export
 * @interface UserCredentialResponseData
 */
export interface UserCredentialResponseData {
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'nickName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'profilePicture'?: string;
    /**
     * 
     * @type {UserCredentialResponseDataMeta}
     * @memberof UserCredentialResponseData
     */
    'meta'?: UserCredentialResponseDataMeta;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'typeLogin'?: string;
    /**
     * 
     * @type {Array<SellerDetail>}
     * @memberof UserCredentialResponseData
     */
    'special'?: Array<SellerDetail>;
    /**
     * 
     * @type {Array<SellerDetail>}
     * @memberof UserCredentialResponseData
     */
    'sellers'?: Array<SellerDetail>;
}
/**
 * 
 * @export
 * @interface UserCredentialResponseDataMeta
 */
export interface UserCredentialResponseDataMeta {
    /**
     * 
     * @type {number}
     * @memberof UserCredentialResponseDataMeta
     */
    'totalBuy'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserCredentialResponseDataMeta
     */
    'totalCancel'?: number;
}
/**
 * 
 * @export
 * @interface UserCredentials
 */
export interface UserCredentials {
    /**
     * 
     * @type {string}
     * @memberof UserCredentials
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentials
     */
    'password': string;
}
/**
 * user detail information
 * @export
 * @interface UserDetail
 */
export interface UserDetail {
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'name'?: string;
    /**
     * 
     * @type {UserDetailMeta}
     * @memberof UserDetail
     */
    'meta'?: UserDetailMeta;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UserDetailMeta
 */
export interface UserDetailMeta {
    /**
     * 
     * @type {number}
     * @memberof UserDetailMeta
     */
    'totalBuy'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserDetailMeta
     */
    'totalCancel'?: string;
}
/**
 * 
 * @export
 * @interface UserMobileRegister
 */
export interface UserMobileRegister {
    /**
     * 
     * @type {string}
     * @memberof UserMobileRegister
     */
    'email': string;
    /**
     * Password must be 8-16 characters and contain both numbers and letters characters
     * @type {string}
     * @memberof UserMobileRegister
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserMobileRegister
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserMobileRegister
     */
    'lastName': string;
    /**
     * it kind of a checkbok
     * @type {string}
     * @memberof UserMobileRegister
     */
    'gender': string;
}
/**
 * 
 * @export
 * @interface UserRegister
 */
export interface UserRegister {
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'email': string;
    /**
     * Password must be 8-16 characters and contain both numbers and letters characters
     * @type {string}
     * @memberof UserRegister
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'lastName': string;
    /**
     * it kind of a checkbok
     * @type {string}
     * @memberof UserRegister
     */
    'gender': string;
}
/**
 * 
 * @export
 * @interface UserRequestSignUpSeller
 */
export interface UserRequestSignUpSeller {
    /**
     * 
     * @type {string}
     * @memberof UserRequestSignUpSeller
     */
    'token': string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user when login by google successfully
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login by google account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOauthGoogleGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/oauth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the token is valid to access the seller register page
         * @param {UserRequestSignUpSeller} [userRequestSignUpSeller] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCheckSellerRegisterRequestPost: async (userRequestSignUpSeller?: UserRequestSignUpSeller, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/check-seller-register-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequestSignUpSeller, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete file by token
         * @param {DeleteImagesRequest} [deleteImagesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDeleteFilesPost: async (deleteImagesRequest?: DeleteImagesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/delete-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteImagesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send mail to reset password - step 1
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailResetPasswordPost: async (forgotPasswordRequest?: ForgotPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/email-reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Login by Email and Password 
         * @param {UserCredentials} [userCredentials] email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (userCredentials?: UserCredentials, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can only log themselves out, not other users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User sign up an local account - spend for mobile
         * @param {UserMobileRegister} [userMobileRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMobileRegisterPost: async (userMobileRegister?: UserMobileRegister, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/mobile-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userMobileRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User active account that it just created - mobile
         * @param {OTPRequestActive} [oTPRequestActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOtpRegisterPost: async (oTPRequestActive?: OTPRequestActive, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/otp-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oTPRequestActive, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OTP matched then server will send for you verify token to reset password - step 2
         * @param {OTPRequest} [oTPRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOtpResetPasswordPost: async (oTPRequest?: OTPRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/otp-reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oTPRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh token when access token is expired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshTokenGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User sign up an local account
         * @param {UserRegister} [userRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost: async (userRegister?: UserRegister, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset password follow by verify token - final step
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordPost: async (resetPasswordRequest?: ResetPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API seller register account
         * @param {SellerRegisterRequest} [sellerRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerRegisterPost: async (sellerRegisterRequest?: SellerRegisterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/seller-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sellerRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User sign up seller account by token and this user need to sign in before
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerRegisterRequestGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/seller-register-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user when login by google successfully
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredentialResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Login by google account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOauthGoogleGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOauthGoogleGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the token is valid to access the seller register page
         * @param {UserRequestSignUpSeller} [userRequestSignUpSeller] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authCheckSellerRegisterRequestPost(userRequestSignUpSeller?: UserRequestSignUpSeller, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCheckSellerRegisterRequestPost(userRequestSignUpSeller, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete file by token
         * @param {DeleteImagesRequest} [deleteImagesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDeleteFilesPost(deleteImagesRequest?: DeleteImagesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDeleteFilesPost(deleteImagesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send mail to reset password - step 1
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authEmailResetPasswordPost(forgotPasswordRequest?: ForgotPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authEmailResetPasswordPost(forgotPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Login by Email and Password 
         * @param {UserCredentials} [userCredentials] email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(userCredentials?: UserCredentials, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredentialResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(userCredentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Users can only log themselves out, not other users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User sign up an local account - spend for mobile
         * @param {UserMobileRegister} [userMobileRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMobileRegisterPost(userMobileRegister?: UserMobileRegister, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMobileRegisterPost(userMobileRegister, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User active account that it just created - mobile
         * @param {OTPRequestActive} [oTPRequestActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOtpRegisterPost(oTPRequestActive?: OTPRequestActive, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOtpRegisterPost(oTPRequestActive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * OTP matched then server will send for you verify token to reset password - step 2
         * @param {OTPRequest} [oTPRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOtpResetPasswordPost(oTPRequest?: OTPRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OTPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOtpResetPasswordPost(oTPRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh token when access token is expired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRefreshTokenGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredentialResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefreshTokenGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User sign up an local account
         * @param {UserRegister} [userRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterPost(userRegister?: UserRegister, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterPost(userRegister, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset password follow by verify token - final step
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authResetPasswordPost(resetPasswordRequest?: ResetPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authResetPasswordPost(resetPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API seller register account
         * @param {SellerRegisterRequest} [sellerRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSellerRegisterPost(sellerRegisterRequest?: SellerRegisterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSellerRegisterPost(sellerRegisterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User sign up seller account by token and this user need to sign in before
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSellerRegisterRequestGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSellerRegisterRequestGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Get user when login by google successfully
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGet(options?: any): AxiosPromise<UserCredentialResponse> {
            return localVarFp.apiMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Login by google account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOauthGoogleGet(options?: any): AxiosPromise<void> {
            return localVarFp.apiOauthGoogleGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the token is valid to access the seller register page
         * @param {UserRequestSignUpSeller} [userRequestSignUpSeller] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCheckSellerRegisterRequestPost(userRequestSignUpSeller?: UserRequestSignUpSeller, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authCheckSellerRegisterRequestPost(userRequestSignUpSeller, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete file by token
         * @param {DeleteImagesRequest} [deleteImagesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDeleteFilesPost(deleteImagesRequest?: DeleteImagesRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authDeleteFilesPost(deleteImagesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send mail to reset password - step 1
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailResetPasswordPost(forgotPasswordRequest?: ForgotPasswordRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authEmailResetPasswordPost(forgotPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User Login by Email and Password 
         * @param {UserCredentials} [userCredentials] email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(userCredentials?: UserCredentials, options?: any): AxiosPromise<UserCredentialResponse> {
            return localVarFp.authLoginPost(userCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Users can only log themselves out, not other users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutGet(options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authLogoutGet(options).then((request) => request(axios, basePath));
        },
        /**
         * User sign up an local account - spend for mobile
         * @param {UserMobileRegister} [userMobileRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMobileRegisterPost(userMobileRegister?: UserMobileRegister, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authMobileRegisterPost(userMobileRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * User active account that it just created - mobile
         * @param {OTPRequestActive} [oTPRequestActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOtpRegisterPost(oTPRequestActive?: OTPRequestActive, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authOtpRegisterPost(oTPRequestActive, options).then((request) => request(axios, basePath));
        },
        /**
         * OTP matched then server will send for you verify token to reset password - step 2
         * @param {OTPRequest} [oTPRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOtpResetPasswordPost(oTPRequest?: OTPRequest, options?: any): AxiosPromise<OTPResponse> {
            return localVarFp.authOtpResetPasswordPost(oTPRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh token when access token is expired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshTokenGet(options?: any): AxiosPromise<UserCredentialResponse> {
            return localVarFp.authRefreshTokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * User sign up an local account
         * @param {UserRegister} [userRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost(userRegister?: UserRegister, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authRegisterPost(userRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset password follow by verify token - final step
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordPost(resetPasswordRequest?: ResetPasswordRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authResetPasswordPost(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API seller register account
         * @param {SellerRegisterRequest} [sellerRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerRegisterPost(sellerRegisterRequest?: SellerRegisterRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authSellerRegisterPost(sellerRegisterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User sign up seller account by token and this user need to sign in before
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerRegisterRequestGet(options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authSellerRegisterRequestGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Get user when login by google successfully
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiMeGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login by google account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiOauthGoogleGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiOauthGoogleGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the token is valid to access the seller register page
     * @param {UserRequestSignUpSeller} [userRequestSignUpSeller] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authCheckSellerRegisterRequestPost(userRequestSignUpSeller?: UserRequestSignUpSeller, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authCheckSellerRegisterRequestPost(userRequestSignUpSeller, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete file by token
     * @param {DeleteImagesRequest} [deleteImagesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authDeleteFilesPost(deleteImagesRequest?: DeleteImagesRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authDeleteFilesPost(deleteImagesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send mail to reset password - step 1
     * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authEmailResetPasswordPost(forgotPasswordRequest?: ForgotPasswordRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authEmailResetPasswordPost(forgotPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Login by Email and Password 
     * @param {UserCredentials} [userCredentials] email and password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginPost(userCredentials?: UserCredentials, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginPost(userCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Users can only log themselves out, not other users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogoutGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogoutGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User sign up an local account - spend for mobile
     * @param {UserMobileRegister} [userMobileRegister] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authMobileRegisterPost(userMobileRegister?: UserMobileRegister, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authMobileRegisterPost(userMobileRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User active account that it just created - mobile
     * @param {OTPRequestActive} [oTPRequestActive] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOtpRegisterPost(oTPRequestActive?: OTPRequestActive, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOtpRegisterPost(oTPRequestActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OTP matched then server will send for you verify token to reset password - step 2
     * @param {OTPRequest} [oTPRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOtpResetPasswordPost(oTPRequest?: OTPRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOtpResetPasswordPost(oTPRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh token when access token is expired
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRefreshTokenGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRefreshTokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User sign up an local account
     * @param {UserRegister} [userRegister] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRegisterPost(userRegister?: UserRegister, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRegisterPost(userRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset password follow by verify token - final step
     * @param {ResetPasswordRequest} [resetPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authResetPasswordPost(resetPasswordRequest?: ResetPasswordRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authResetPasswordPost(resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API seller register account
     * @param {SellerRegisterRequest} [sellerRegisterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSellerRegisterPost(sellerRegisterRequest?: SellerRegisterRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSellerRegisterPost(sellerRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User sign up seller account by token and this user need to sign in before
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSellerRegisterRequestGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSellerRegisterRequestGet(options).then((request) => request(this.axios, this.basePath));
    }
}


