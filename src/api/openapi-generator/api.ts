/* tslint:disable */
/* eslint-disable */
/**
 * BT API document
 * This is a BT API document
 *
 * The version of the OpenAPI document: 1.0.1
 * Contact: baotrandinh100@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddProductRequest
 */
export interface AddProductRequest {
    /**
     * 
     * @type {string}
     * @memberof AddProductRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AddProductRequest
     */
    'category': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddProductRequest
     */
    'productPictures'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AddProductRequest
     */
    'description'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof AddProductRequest
     */
    'variants'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof AddProductRequest
     */
    'specs'?: Array<object>;
}
/**
 * 
 * @export
 * @interface AnnouceSuccess
 */
export interface AnnouceSuccess {
    /**
     * 
     * @type {number}
     * @memberof AnnouceSuccess
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnouceSuccess
     */
    'message'?: string;
    /**
     * 
     * @type {object}
     * @memberof AnnouceSuccess
     */
    'data'?: object;
}
/**
 * 
 * @export
 * @interface AnnouceSuccessAuth
 */
export interface AnnouceSuccessAuth {
    /**
     * 
     * @type {AnnouceSuccessAuthData}
     * @memberof AnnouceSuccessAuth
     */
    'data'?: AnnouceSuccessAuthData;
    /**
     * it use to validate with backend
     * @type {string}
     * @memberof AnnouceSuccessAuth
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface AnnouceSuccessAuthData
 */
export interface AnnouceSuccessAuthData {
    /**
     * 
     * @type {string}
     * @memberof AnnouceSuccessAuthData
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface CancelOrderRequest
 */
export interface CancelOrderRequest {
    /**
     * 
     * @type {string}
     * @memberof CancelOrderRequest
     */
    'orderItemId'?: string;
    /**
     * 
     * @type {string}
     * @memberof CancelOrderRequest
     */
    'reason'?: string;
}
/**
 * 
 * @export
 * @interface CategoriesResponse
 */
export interface CategoriesResponse {
    /**
     * 
     * @type {Array<object>}
     * @memberof CategoriesResponse
     */
    'data'?: Array<object>;
}
/**
 * 
 * @export
 * @interface CategoryInfo
 */
export interface CategoryInfo {
    /**
     * 
     * @type {string}
     * @memberof CategoryInfo
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryInfo
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryInfo
     */
    'categoryImage'?: string;
}
/**
 * 
 * @export
 * @interface CategoryRequest
 */
export interface CategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof CategoryRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CategoryRequest
     */
    'categoryImage'?: string;
}
/**
 * API to save a list of photos to delete
 * @export
 * @interface DeleteImagesRequest
 */
export interface DeleteImagesRequest {
    /**
     * the field that it is unique
     * @type {string}
     * @memberof DeleteImagesRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeleteImagesRequest
     */
    'token'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteImagesRequest
     */
    'fileList'?: Array<string>;
}
/**
 * Error responses are sent when an error (e.g. unauthorized, bad request) occurred.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * the status of response.
     * @type {number}
     * @memberof ErrorResponse
     */
    'status'?: number;
    /**
     * 
     * @type {ErrorResponseErrors}
     * @memberof ErrorResponse
     */
    'errors'?: ErrorResponseErrors;
}
/**
 * 
 * @export
 * @interface ErrorResponseErrors
 */
export interface ErrorResponseErrors {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseErrors
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface FileInfo
 */
export interface FileInfo {
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'fileLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'fileId'?: string;
}
/**
 * 
 * @export
 * @interface ForgotPasswordRequest
 */
export interface ForgotPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface GoogleLoginRequest
 */
export interface GoogleLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof GoogleLoginRequest
     */
    'accessToken': string;
}
/**
 * 
 * @export
 * @interface LogoutRequest
 */
export interface LogoutRequest {
    /**
     * 
     * @type {string}
     * @memberof LogoutRequest
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof LogoutRequest
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface MetaProduct
 */
export interface MetaProduct {
    /**
     * 
     * @type {number}
     * @memberof MetaProduct
     */
    'totalSold'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaProduct
     */
    'totalOrder'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaProduct
     */
    'totalReview'?: number;
}
/**
 * some information that it relate the shop of seller
 * @export
 * @interface MetaSeller
 */
export interface MetaSeller {
    /**
     * 
     * @type {number}
     * @memberof MetaSeller
     */
    'totalSole'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaSeller
     */
    'totalProduct'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaSeller
     */
    'totalEvaluation'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaSeller
     */
    'ranking'?: number;
    /**
     * 
     * @type {string}
     * @memberof MetaSeller
     */
    'title'?: string;
}
/**
 * OTP got from your email
 * @export
 * @interface OTPRequestActive
 */
export interface OTPRequestActive {
    /**
     * 
     * @type {string}
     * @memberof OTPRequestActive
     */
    'userId': string;
    /**
     * 
     * @type {number}
     * @memberof OTPRequestActive
     */
    'otp': number;
}
/**
 * 
 * @export
 * @interface OrderDetails
 */
export interface OrderDetails {
    /**
     * 
     * @type {string}
     * @memberof OrderDetails
     */
    '_id'?: string;
    /**
     * 
     * @type {OrderDetailsUser}
     * @memberof OrderDetails
     */
    'user'?: OrderDetailsUser;
    /**
     * 
     * @type {OrderDetailsAddress}
     * @memberof OrderDetails
     */
    'address'?: OrderDetailsAddress;
    /**
     * 
     * @type {string}
     * @memberof OrderDetails
     */
    'paymentType'?: string;
    /**
     * 
     * @type {Array<OrderDetailsItemsInner>}
     * @memberof OrderDetails
     */
    'items'?: Array<OrderDetailsItemsInner>;
    /**
     * 
     * @type {OrderDetailsProduct}
     * @memberof OrderDetails
     */
    'product'?: OrderDetailsProduct;
}
/**
 * 
 * @export
 * @interface OrderDetailsAddress
 */
export interface OrderDetailsAddress {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsAddress
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsAddress
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsAddress
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsAddress
     */
    'zipCode'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDetailsAddress
     */
    'isDefault'?: boolean;
}
/**
 * 
 * @export
 * @interface OrderDetailsItemsInner
 */
export interface OrderDetailsItemsInner {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsItemsInner
     */
    'product'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsItemsInner
     */
    'shippingCode'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsItemsInner
     */
    'discount'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsItemsInner
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsItemsInner
     */
    'totalPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsItemsInner
     */
    'quantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsItemsInner
     */
    'shippingCost'?: number;
    /**
     * 
     * @type {Array<OrderDetailsItemsInnerOrderStatusInner>}
     * @memberof OrderDetailsItemsInner
     */
    'orderStatus'?: Array<OrderDetailsItemsInnerOrderStatusInner>;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsItemsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsItemsInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsItemsInner
     */
    '_id'?: string;
}
/**
 * 
 * @export
 * @interface OrderDetailsItemsInnerOrderStatusInner
 */
export interface OrderDetailsItemsInnerOrderStatusInner {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsItemsInnerOrderStatusInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsItemsInnerOrderStatusInner
     */
    'date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDetailsItemsInnerOrderStatusInner
     */
    'isCompleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsItemsInnerOrderStatusInner
     */
    '_id'?: string;
}
/**
 * 
 * @export
 * @interface OrderDetailsProduct
 */
export interface OrderDetailsProduct {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsProduct
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsProduct
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsProduct
     */
    'quantity'?: number;
    /**
     * 
     * @type {Array<OrderDetailsProductProductPicturesInner>}
     * @memberof OrderDetailsProduct
     */
    'productPictures'?: Array<OrderDetailsProductProductPicturesInner>;
    /**
     * 
     * @type {OrderDetailsUserMeta}
     * @memberof OrderDetailsProduct
     */
    'meta'?: OrderDetailsUserMeta;
    /**
     * 
     * @type {Array<object>}
     * @memberof OrderDetailsProduct
     */
    'variants'?: Array<object>;
}
/**
 * 
 * @export
 * @interface OrderDetailsProductProductPicturesInner
 */
export interface OrderDetailsProductProductPicturesInner {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsProductProductPicturesInner
     */
    'fileId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsProductProductPicturesInner
     */
    'fileLink'?: string;
}
/**
 * 
 * @export
 * @interface OrderDetailsShipping
 */
export interface OrderDetailsShipping {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsShipping
     */
    '_id'?: string;
    /**
     * 
     * @type {object}
     * @memberof OrderDetailsShipping
     */
    'product'?: object;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsShipping
     */
    'totalPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsShipping
     */
    'quantity'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDetailsShipping
     */
    'isCancel'?: boolean;
    /**
     * 
     * @type {Array<OrderDetailsItemsInnerOrderStatusInner>}
     * @memberof OrderDetailsShipping
     */
    'orderStatus'?: Array<OrderDetailsItemsInnerOrderStatusInner>;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsShipping
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsShipping
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {OrderDetailsShippingAddress}
     * @memberof OrderDetailsShipping
     */
    'address'?: OrderDetailsShippingAddress;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsShipping
     */
    'paymentType'?: string;
}
/**
 * 
 * @export
 * @interface OrderDetailsShippingAddress
 */
export interface OrderDetailsShippingAddress {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsShippingAddress
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsShippingAddress
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsShippingAddress
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsShippingAddress
     */
    'zipCode'?: number;
}
/**
 * 
 * @export
 * @interface OrderDetailsUser
 */
export interface OrderDetailsUser {
    /**
     * 
     * @type {OrderDetailsUserInfo}
     * @memberof OrderDetailsUser
     */
    'info'?: OrderDetailsUserInfo;
    /**
     * 
     * @type {OrderDetailsUserMeta}
     * @memberof OrderDetailsUser
     */
    'meta'?: OrderDetailsUserMeta;
}
/**
 * 
 * @export
 * @interface OrderDetailsUserInfo
 */
export interface OrderDetailsUserInfo {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsUserInfo
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsUserInfo
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsUserInfo
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsUserInfo
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsUserInfo
     */
    'birthDay'?: string;
}
/**
 * 
 * @export
 * @interface OrderDetailsUserMeta
 */
export interface OrderDetailsUserMeta {
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsUserMeta
     */
    'totalBuy'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsUserMeta
     */
    'totalCancel'?: number;
}
/**
 * 
 * @export
 * @interface OrderList
 */
export interface OrderList {
    /**
     * 
     * @type {number}
     * @memberof OrderList
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderList
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderList
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderList
     */
    'total_page'?: number;
    /**
     * 
     * @type {Array<OrderDetails>}
     * @memberof OrderList
     */
    'data'?: Array<OrderDetails>;
}
/**
 * 
 * @export
 * @interface OrderListShipping
 */
export interface OrderListShipping {
    /**
     * 
     * @type {number}
     * @memberof OrderListShipping
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderListShipping
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderListShipping
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderListShipping
     */
    'total_page'?: number;
    /**
     * 
     * @type {Array<OrderDetailsShipping>}
     * @memberof OrderListShipping
     */
    'data'?: Array<OrderDetailsShipping>;
}
/**
 * 
 * @export
 * @interface ProductDetails
 */
export interface ProductDetails {
    /**
     * 
     * @type {string}
     * @memberof ProductDetails
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDetails
     */
    'name'?: string;
    /**
     * 
     * @type {SellerDetail}
     * @memberof ProductDetails
     */
    'seller'?: SellerDetail;
    /**
     * 
     * @type {string}
     * @memberof ProductDetails
     */
    'slug'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductDetails
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDetails
     */
    'discountPercent'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDetails
     */
    'summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDetails
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductDetails
     */
    'quantity'?: number;
    /**
     * 
     * @type {Array<FileInfo>}
     * @memberof ProductDetails
     */
    'productPictures'?: Array<FileInfo>;
    /**
     * 
     * @type {CategoryInfo}
     * @memberof ProductDetails
     */
    'category'?: CategoryInfo;
    /**
     * 
     * @type {SpecsProduct}
     * @memberof ProductDetails
     */
    'specs'?: SpecsProduct;
    /**
     * 
     * @type {MetaProduct}
     * @memberof ProductDetails
     */
    'meta'?: MetaProduct;
}
/**
 * 
 * @export
 * @interface ProductDetailsResponse
 */
export interface ProductDetailsResponse {
    /**
     * 
     * @type {ProductDetails}
     * @memberof ProductDetailsResponse
     */
    'data'?: ProductDetails;
}
/**
 * 
 * @export
 * @interface ProductsResponse
 */
export interface ProductsResponse {
    /**
     * 
     * @type {Array<object>}
     * @memberof ProductsResponse
     */
    'data'?: Array<object>;
    /**
     * 
     * @type {number}
     * @memberof ProductsResponse
     */
    'total'?: number;
}
/**
 * 
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'password': string;
}
/**
 * Seller detail information
 * @export
 * @interface SellerDetail
 */
export interface SellerDetail {
    /**
     * 
     * @type {string}
     * @memberof SellerDetail
     */
    '_id'?: string;
    /**
     * 
     * @type {SellerDetailInfo}
     * @memberof SellerDetail
     */
    'info'?: SellerDetailInfo;
    /**
     * 
     * @type {SellerDetailLogo}
     * @memberof SellerDetail
     */
    'logo'?: SellerDetailLogo;
    /**
     * 
     * @type {string}
     * @memberof SellerDetail
     */
    'slogan'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerDetail
     */
    'type'?: string;
    /**
     * 
     * @type {MetaSeller}
     * @memberof SellerDetail
     */
    'meta'?: MetaSeller;
    /**
     * to implement lock the account of seller
     * @type {boolean}
     * @memberof SellerDetail
     */
    'isDisable'?: boolean;
}
/**
 * 
 * @export
 * @interface SellerDetailInfo
 */
export interface SellerDetailInfo {
    /**
     * 
     * @type {string}
     * @memberof SellerDetailInfo
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SellerDetailInfo
     */
    'address'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SellerDetailInfo
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface SellerDetailLogo
 */
export interface SellerDetailLogo {
    /**
     * 
     * @type {string}
     * @memberof SellerDetailLogo
     */
    'fileLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerDetailLogo
     */
    'fileId'?: string;
}
/**
 * the info of seller will send to server to create a seller account
 * @export
 * @interface SellerRegisterRequest
 */
export interface SellerRegisterRequest {
    /**
     * check role
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'facebook'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'instagram'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'youtube'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'linkedin'?: string;
    /**
     * name is unique
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'slogan': string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'address'?: string;
    /**
     * It help the seller confirm the Genuine Store
     * @type {Array<string>}
     * @memberof SellerRegisterRequest
     */
    'proof'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SendOTPAgain
 */
export interface SendOTPAgain {
    /**
     * 
     * @type {string}
     * @memberof SendOTPAgain
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface SpecsProduct
 */
export interface SpecsProduct {
    /**
     * 
     * @type {string}
     * @memberof SpecsProduct
     */
    'author'?: string;
    /**
     * 
     * @type {number}
     * @memberof SpecsProduct
     */
    'printLength'?: number;
    /**
     * 
     * @type {string}
     * @memberof SpecsProduct
     */
    'publisher'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecsProduct
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecsProduct
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecsProduct
     */
    'publicationDate'?: string;
}
/**
 * 
 * @export
 * @interface UpdateStatusOrderRequest
 */
export interface UpdateStatusOrderRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateStatusOrderRequest
     */
    'orderItemId'?: string;
}
/**
 * 
 * @export
 * @interface UserCredentialResponse
 */
export interface UserCredentialResponse {
    /**
     * 
     * @type {number}
     * @memberof UserCredentialResponse
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponse
     */
    'message'?: string;
    /**
     * 
     * @type {UserCredentialResponseData}
     * @memberof UserCredentialResponse
     */
    'data': UserCredentialResponseData;
}
/**
 * 
 * @export
 * @interface UserCredentialResponseData
 */
export interface UserCredentialResponseData {
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'nickName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'role': string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'avatar': string;
    /**
     * 
     * @type {UserCredentialResponseDataMeta}
     * @memberof UserCredentialResponseData
     */
    'meta'?: UserCredentialResponseDataMeta;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'typeLogin': string;
    /**
     * 
     * @type {SellerDetail}
     * @memberof UserCredentialResponseData
     */
    'seller'?: SellerDetail;
    /**
     * 
     * @type {Array<object>}
     * @memberof UserCredentialResponseData
     */
    'special'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface UserCredentialResponseDataMeta
 */
export interface UserCredentialResponseDataMeta {
    /**
     * 
     * @type {number}
     * @memberof UserCredentialResponseDataMeta
     */
    'totalBuy'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserCredentialResponseDataMeta
     */
    'totalCancel'?: number;
}
/**
 * 
 * @export
 * @interface UserCredentials
 */
export interface UserCredentials {
    /**
     * 
     * @type {string}
     * @memberof UserCredentials
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentials
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UserListResponse
 */
export interface UserListResponse {
    /**
     * 
     * @type {number}
     * @memberof UserListResponse
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserListResponse
     */
    'message'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof UserListResponse
     */
    'data'?: Array<object>;
}
/**
 * 
 * @export
 * @interface UserLogoutRequest
 */
export interface UserLogoutRequest {
    /**
     * 
     * @type {string}
     * @memberof UserLogoutRequest
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface UserMobileRegister
 */
export interface UserMobileRegister {
    /**
     * 
     * @type {string}
     * @memberof UserMobileRegister
     */
    'email': string;
    /**
     * Password must be 8-16 characters and contain both numbers and letters characters
     * @type {string}
     * @memberof UserMobileRegister
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserMobileRegister
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserMobileRegister
     */
    'lastName': string;
    /**
     * it kind of a checkbok
     * @type {string}
     * @memberof UserMobileRegister
     */
    'gender': string;
}
/**
 * 
 * @export
 * @interface UserRegister
 */
export interface UserRegister {
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'email': string;
    /**
     * Password must be 8-16 characters and contain both numbers and letters characters
     * @type {string}
     * @memberof UserRegister
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'lastName': string;
    /**
     * it kind of a checkbok
     * @type {string}
     * @memberof UserRegister
     */
    'gender': string;
}
/**
 * 
 * @export
 * @interface UserRequestSignUpSeller
 */
export interface UserRequestSignUpSeller {
    /**
     * 
     * @type {string}
     * @memberof UserRequestSignUpSeller
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface UserSignUp
 */
export interface UserSignUp {
    /**
     * 
     * @type {string}
     * @memberof UserSignUp
     */
    'email': string;
    /**
     * Password must be 8-16 characters and contain both numbers and letters characters
     * @type {string}
     * @memberof UserSignUp
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUp
     */
    'name': string;
    /**
     * it kind of a checkbok
     * @type {string}
     * @memberof UserSignUp
     */
    'gender': string;
    /**
     * 
     * @type {string}
     * @memberof UserSignUp
     */
    'bithDay'?: string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * get user list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserAllGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/user/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * block account
         * @param {UserLogoutRequest} [userLogoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserBlockPut: async (userLogoutRequest?: UserLogoutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/user/block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLogoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update category by admin
         * @param {UserLogoutRequest} [userLogoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserLogoutPost: async (userLogoutRequest?: UserLogoutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/user/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLogoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * unblock account
         * @param {UserLogoutRequest} [userLogoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserUnblockPut: async (userLogoutRequest?: UserLogoutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/user/unblock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLogoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a category from admin
         * @param {CategoryRequest} [categoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryAddPost: async (categoryRequest?: CategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update category by admin
         * @param {string} [slug] 
         * @param {CategoryRequest} [categoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryEditPut: async (slug?: string, categoryRequest?: CategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category/edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * get user list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUserAllGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserAllGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * block account
         * @param {UserLogoutRequest} [userLogoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUserBlockPut(userLogoutRequest?: UserLogoutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserBlockPut(userLogoutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update category by admin
         * @param {UserLogoutRequest} [userLogoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUserLogoutPost(userLogoutRequest?: UserLogoutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserLogoutPost(userLogoutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * unblock account
         * @param {UserLogoutRequest} [userLogoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminUserUnblockPut(userLogoutRequest?: UserLogoutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminUserUnblockPut(userLogoutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a category from admin
         * @param {CategoryRequest} [categoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryAddPost(categoryRequest?: CategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryAddPost(categoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update category by admin
         * @param {string} [slug] 
         * @param {CategoryRequest} [categoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryEditPut(slug?: string, categoryRequest?: CategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryEditPut(slug, categoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * get user list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserAllGet(options?: any): AxiosPromise<UserListResponse> {
            return localVarFp.adminUserAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * block account
         * @param {UserLogoutRequest} [userLogoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserBlockPut(userLogoutRequest?: UserLogoutRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.adminUserBlockPut(userLogoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * update category by admin
         * @param {UserLogoutRequest} [userLogoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserLogoutPost(userLogoutRequest?: UserLogoutRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.adminUserLogoutPost(userLogoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * unblock account
         * @param {UserLogoutRequest} [userLogoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminUserUnblockPut(userLogoutRequest?: UserLogoutRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.adminUserUnblockPut(userLogoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a category from admin
         * @param {CategoryRequest} [categoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryAddPost(categoryRequest?: CategoryRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.categoryAddPost(categoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * update category by admin
         * @param {string} [slug] 
         * @param {CategoryRequest} [categoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryEditPut(slug?: string, categoryRequest?: CategoryRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.categoryEditPut(slug, categoryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * get user list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUserAllGet(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUserAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * block account
     * @param {UserLogoutRequest} [userLogoutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUserBlockPut(userLogoutRequest?: UserLogoutRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUserBlockPut(userLogoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update category by admin
     * @param {UserLogoutRequest} [userLogoutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUserLogoutPost(userLogoutRequest?: UserLogoutRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUserLogoutPost(userLogoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * unblock account
     * @param {UserLogoutRequest} [userLogoutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminUserUnblockPut(userLogoutRequest?: UserLogoutRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminUserUnblockPut(userLogoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a category from admin
     * @param {CategoryRequest} [categoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public categoryAddPost(categoryRequest?: CategoryRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).categoryAddPost(categoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update category by admin
     * @param {string} [slug] 
     * @param {CategoryRequest} [categoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public categoryEditPut(slug?: string, categoryRequest?: CategoryRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).categoryEditPut(slug, categoryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check the token is valid to access the seller register page
         * @param {UserRequestSignUpSeller} [userRequestSignUpSeller] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCheckSellerRegisterRequestPost: async (userRequestSignUpSeller?: UserRequestSignUpSeller, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/check-seller-register-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequestSignUpSeller, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete file by token
         * @param {DeleteImagesRequest} [deleteImagesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDeleteFilesPost: async (deleteImagesRequest?: DeleteImagesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/delete-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteImagesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send mail to reset password - step 1
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailResetPasswordPost: async (forgotPasswordRequest?: ForgotPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/email-reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Login by Email and Password 
         * @param {UserCredentials} [userCredentials] email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (userCredentials?: UserCredentials, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * clear token redis
         * @param {LogoutRequest} [logoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPost: async (logoutRequest?: LogoutRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logoutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User sign up an local account - spend for mobile
         * @param {UserMobileRegister} [userMobileRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMobileRegisterPost: async (userMobileRegister?: UserMobileRegister, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/mobile-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userMobileRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login by google account if not existed then create
         * @param {GoogleLoginRequest} [googleLoginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOauthGooglePost: async (googleLoginRequest?: GoogleLoginRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/oauth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(googleLoginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User active account that it just created - mobile
         * @param {OTPRequestActive} [oTPRequestActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOtpRegisterPost: async (oTPRequestActive?: OTPRequestActive, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/otp-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oTPRequestActive, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send mail to reset password
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordEmailPost: async (forgotPasswordRequest?: ForgotPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/password/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Token matched then server will send for you verify token to reset password
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordResetPost: async (resetPasswordRequest?: ResetPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/password/reset`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh token when access token is expired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshTokenGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User sign up an local account
         * @param {UserRegister} [userRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost: async (userRegister?: UserRegister, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request send otp again
         * @param {SendOTPAgain} [sendOTPAgain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterSendOtpAgainPost: async (sendOTPAgain?: SendOTPAgain, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/register/send-otp-again`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendOTPAgain, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset password follow by verify token - final step
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordPost: async (resetPasswordRequest?: ResetPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * create a new seller
         * @param {SellerRegisterRequest} [sellerRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerCreatePost: async (sellerRegisterRequest?: SellerRegisterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/seller/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sellerRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * send request to sign up seller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerRegisterGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/seller/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API seller register account
         * @param {SellerRegisterRequest} [sellerRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerRegisterPost: async (sellerRegisterRequest?: SellerRegisterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/seller-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sellerRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User sign up seller account by token and this user need to sign in before
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerRegisterRequestGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/seller-register-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User sign up an local account
         * @param {UserSignUp} [userSignUp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignupPost: async (userSignUp?: UserSignUp, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/signup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSignUp, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * check token expire or exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenCheckGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/token/check`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Check the token is valid to access the seller register page
         * @param {UserRequestSignUpSeller} [userRequestSignUpSeller] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authCheckSellerRegisterRequestPost(userRequestSignUpSeller?: UserRequestSignUpSeller, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCheckSellerRegisterRequestPost(userRequestSignUpSeller, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete file by token
         * @param {DeleteImagesRequest} [deleteImagesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDeleteFilesPost(deleteImagesRequest?: DeleteImagesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDeleteFilesPost(deleteImagesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send mail to reset password - step 1
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authEmailResetPasswordPost(forgotPasswordRequest?: ForgotPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccessAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authEmailResetPasswordPost(forgotPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Login by Email and Password 
         * @param {UserCredentials} [userCredentials] email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(userCredentials?: UserCredentials, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredentialResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(userCredentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * clear token redis
         * @param {LogoutRequest} [logoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutPost(logoutRequest?: LogoutRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutPost(logoutRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User sign up an local account - spend for mobile
         * @param {UserMobileRegister} [userMobileRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMobileRegisterPost(userMobileRegister?: UserMobileRegister, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccessAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMobileRegisterPost(userMobileRegister, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Login by google account if not existed then create
         * @param {GoogleLoginRequest} [googleLoginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOauthGooglePost(googleLoginRequest?: GoogleLoginRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredentialResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOauthGooglePost(googleLoginRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User active account that it just created - mobile
         * @param {OTPRequestActive} [oTPRequestActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOtpRegisterPost(oTPRequestActive?: OTPRequestActive, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOtpRegisterPost(oTPRequestActive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send mail to reset password
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authPasswordEmailPost(forgotPasswordRequest?: ForgotPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authPasswordEmailPost(forgotPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Token matched then server will send for you verify token to reset password
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authPasswordResetPost(resetPasswordRequest?: ResetPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authPasswordResetPost(resetPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh token when access token is expired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRefreshTokenGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredentialResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefreshTokenGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User sign up an local account
         * @param {UserRegister} [userRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterPost(userRegister?: UserRegister, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterPost(userRegister, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Request send otp again
         * @param {SendOTPAgain} [sendOTPAgain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterSendOtpAgainPost(sendOTPAgain?: SendOTPAgain, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccessAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterSendOtpAgainPost(sendOTPAgain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset password follow by verify token - final step
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authResetPasswordPost(resetPasswordRequest?: ResetPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authResetPasswordPost(resetPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * create a new seller
         * @param {SellerRegisterRequest} [sellerRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSellerCreatePost(sellerRegisterRequest?: SellerRegisterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSellerCreatePost(sellerRegisterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * send request to sign up seller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSellerRegisterGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSellerRegisterGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API seller register account
         * @param {SellerRegisterRequest} [sellerRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSellerRegisterPost(sellerRegisterRequest?: SellerRegisterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSellerRegisterPost(sellerRegisterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User sign up seller account by token and this user need to sign in before
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSellerRegisterRequestGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSellerRegisterRequestGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User sign up an local account
         * @param {UserSignUp} [userSignUp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSignupPost(userSignUp?: UserSignUp, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSignupPost(userSignUp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * check token expire or exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenCheckGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenCheckGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Check the token is valid to access the seller register page
         * @param {UserRequestSignUpSeller} [userRequestSignUpSeller] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCheckSellerRegisterRequestPost(userRequestSignUpSeller?: UserRequestSignUpSeller, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authCheckSellerRegisterRequestPost(userRequestSignUpSeller, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete file by token
         * @param {DeleteImagesRequest} [deleteImagesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDeleteFilesPost(deleteImagesRequest?: DeleteImagesRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authDeleteFilesPost(deleteImagesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send mail to reset password - step 1
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailResetPasswordPost(forgotPasswordRequest?: ForgotPasswordRequest, options?: any): AxiosPromise<AnnouceSuccessAuth> {
            return localVarFp.authEmailResetPasswordPost(forgotPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User Login by Email and Password 
         * @param {UserCredentials} [userCredentials] email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(userCredentials?: UserCredentials, options?: any): AxiosPromise<UserCredentialResponse> {
            return localVarFp.authLoginPost(userCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * clear token redis
         * @param {LogoutRequest} [logoutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutPost(logoutRequest?: LogoutRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authLogoutPost(logoutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User sign up an local account - spend for mobile
         * @param {UserMobileRegister} [userMobileRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMobileRegisterPost(userMobileRegister?: UserMobileRegister, options?: any): AxiosPromise<AnnouceSuccessAuth> {
            return localVarFp.authMobileRegisterPost(userMobileRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * Login by google account if not existed then create
         * @param {GoogleLoginRequest} [googleLoginRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOauthGooglePost(googleLoginRequest?: GoogleLoginRequest, options?: any): AxiosPromise<UserCredentialResponse> {
            return localVarFp.authOauthGooglePost(googleLoginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User active account that it just created - mobile
         * @param {OTPRequestActive} [oTPRequestActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOtpRegisterPost(oTPRequestActive?: OTPRequestActive, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authOtpRegisterPost(oTPRequestActive, options).then((request) => request(axios, basePath));
        },
        /**
         * Send mail to reset password
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordEmailPost(forgotPasswordRequest?: ForgotPasswordRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authPasswordEmailPost(forgotPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Token matched then server will send for you verify token to reset password
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authPasswordResetPost(resetPasswordRequest?: ResetPasswordRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authPasswordResetPost(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh token when access token is expired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshTokenGet(options?: any): AxiosPromise<UserCredentialResponse> {
            return localVarFp.authRefreshTokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * User sign up an local account
         * @param {UserRegister} [userRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost(userRegister?: UserRegister, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authRegisterPost(userRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * Request send otp again
         * @param {SendOTPAgain} [sendOTPAgain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterSendOtpAgainPost(sendOTPAgain?: SendOTPAgain, options?: any): AxiosPromise<AnnouceSuccessAuth> {
            return localVarFp.authRegisterSendOtpAgainPost(sendOTPAgain, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset password follow by verify token - final step
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordPost(resetPasswordRequest?: ResetPasswordRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authResetPasswordPost(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * create a new seller
         * @param {SellerRegisterRequest} [sellerRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerCreatePost(sellerRegisterRequest?: SellerRegisterRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authSellerCreatePost(sellerRegisterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * send request to sign up seller
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerRegisterGet(options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authSellerRegisterGet(options).then((request) => request(axios, basePath));
        },
        /**
         * API seller register account
         * @param {SellerRegisterRequest} [sellerRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerRegisterPost(sellerRegisterRequest?: SellerRegisterRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authSellerRegisterPost(sellerRegisterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User sign up seller account by token and this user need to sign in before
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerRegisterRequestGet(options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authSellerRegisterRequestGet(options).then((request) => request(axios, basePath));
        },
        /**
         * User sign up an local account
         * @param {UserSignUp} [userSignUp] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSignupPost(userSignUp?: UserSignUp, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authSignupPost(userSignUp, options).then((request) => request(axios, basePath));
        },
        /**
         * check token expire or exists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenCheckGet(options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authTokenCheckGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Check the token is valid to access the seller register page
     * @param {UserRequestSignUpSeller} [userRequestSignUpSeller] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authCheckSellerRegisterRequestPost(userRequestSignUpSeller?: UserRequestSignUpSeller, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authCheckSellerRegisterRequestPost(userRequestSignUpSeller, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete file by token
     * @param {DeleteImagesRequest} [deleteImagesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authDeleteFilesPost(deleteImagesRequest?: DeleteImagesRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authDeleteFilesPost(deleteImagesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send mail to reset password - step 1
     * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authEmailResetPasswordPost(forgotPasswordRequest?: ForgotPasswordRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authEmailResetPasswordPost(forgotPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Login by Email and Password 
     * @param {UserCredentials} [userCredentials] email and password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginPost(userCredentials?: UserCredentials, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginPost(userCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * clear token redis
     * @param {LogoutRequest} [logoutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogoutPost(logoutRequest?: LogoutRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogoutPost(logoutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User sign up an local account - spend for mobile
     * @param {UserMobileRegister} [userMobileRegister] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authMobileRegisterPost(userMobileRegister?: UserMobileRegister, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authMobileRegisterPost(userMobileRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login by google account if not existed then create
     * @param {GoogleLoginRequest} [googleLoginRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOauthGooglePost(googleLoginRequest?: GoogleLoginRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOauthGooglePost(googleLoginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User active account that it just created - mobile
     * @param {OTPRequestActive} [oTPRequestActive] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOtpRegisterPost(oTPRequestActive?: OTPRequestActive, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOtpRegisterPost(oTPRequestActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send mail to reset password
     * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authPasswordEmailPost(forgotPasswordRequest?: ForgotPasswordRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authPasswordEmailPost(forgotPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Token matched then server will send for you verify token to reset password
     * @param {ResetPasswordRequest} [resetPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authPasswordResetPost(resetPasswordRequest?: ResetPasswordRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authPasswordResetPost(resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh token when access token is expired
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRefreshTokenGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRefreshTokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User sign up an local account
     * @param {UserRegister} [userRegister] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRegisterPost(userRegister?: UserRegister, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRegisterPost(userRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request send otp again
     * @param {SendOTPAgain} [sendOTPAgain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRegisterSendOtpAgainPost(sendOTPAgain?: SendOTPAgain, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRegisterSendOtpAgainPost(sendOTPAgain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset password follow by verify token - final step
     * @param {ResetPasswordRequest} [resetPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authResetPasswordPost(resetPasswordRequest?: ResetPasswordRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authResetPasswordPost(resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * create a new seller
     * @param {SellerRegisterRequest} [sellerRegisterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSellerCreatePost(sellerRegisterRequest?: SellerRegisterRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSellerCreatePost(sellerRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * send request to sign up seller
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSellerRegisterGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSellerRegisterGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API seller register account
     * @param {SellerRegisterRequest} [sellerRegisterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSellerRegisterPost(sellerRegisterRequest?: SellerRegisterRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSellerRegisterPost(sellerRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User sign up seller account by token and this user need to sign in before
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSellerRegisterRequestGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSellerRegisterRequestGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User sign up an local account
     * @param {UserSignUp} [userSignUp] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSignupPost(userSignUp?: UserSignUp, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSignupPost(userSignUp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * check token expire or exists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenCheckGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenCheckGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all categories from database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryAllGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/category/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get products follow by sellerId or not combine with category name
         * @param {string} [categoryName] search products by categoryName
         * @param {number} [limit] The numbers of items to return
         * @param {string} [sellerId] search products by seller id
         * @param {number} [page] the current page of web site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategorySearchGet: async (categoryName?: string, limit?: number, sellerId?: string, page?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/category/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (categoryName !== undefined) {
                localVarQueryParameter['categoryName'] = categoryName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sellerId !== undefined) {
                localVarQueryParameter['sellerId'] = sellerId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get products follow by filter that it get from url,example - /products?sellerId=sellerId&price[gt]=2000
         * @param {string} [name] search products by name
         * @param {number} [limit] The numbers of items to return
         * @param {string} [sellerId] search products by seller id
         * @param {string} [category] search products by category id
         * @param {number} [page] the current page of web site
         * @param {string} [order] 
         * @param {number} [priceGte] find products that it &gt;&#x3D; the price inputted
         * @param {number} [priceGt] 
         * @param {number} [priceLte] &lt;&#x3D;
         * @param {number} [priceLt] &lt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productListGet: async (name?: string, limit?: number, sellerId?: string, category?: string, page?: number, order?: string, priceGte?: number, priceGt?: number, priceLte?: number, priceLt?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sellerId !== undefined) {
                localVarQueryParameter['sellerId'] = sellerId;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (priceGte !== undefined) {
                localVarQueryParameter['price[gte]'] = priceGte;
            }

            if (priceGt !== undefined) {
                localVarQueryParameter['price[gt]'] = priceGt;
            }

            if (priceLte !== undefined) {
                localVarQueryParameter['price[lte]'] = priceLte;
            }

            if (priceLt !== undefined) {
                localVarQueryParameter['price[lt]'] = priceLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get product by slug
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productSlugGet: async (slug: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('productSlugGet', 'slug', slug)
            const localVarPath = `/product/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all categories from database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoryAllGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoryAllGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get products follow by sellerId or not combine with category name
         * @param {string} [categoryName] search products by categoryName
         * @param {number} [limit] The numbers of items to return
         * @param {string} [sellerId] search products by seller id
         * @param {number} [page] the current page of web site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productCategorySearchGet(categoryName?: string, limit?: number, sellerId?: string, page?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productCategorySearchGet(categoryName, limit, sellerId, page, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get products follow by filter that it get from url,example - /products?sellerId=sellerId&price[gt]=2000
         * @param {string} [name] search products by name
         * @param {number} [limit] The numbers of items to return
         * @param {string} [sellerId] search products by seller id
         * @param {string} [category] search products by category id
         * @param {number} [page] the current page of web site
         * @param {string} [order] 
         * @param {number} [priceGte] find products that it &gt;&#x3D; the price inputted
         * @param {number} [priceGt] 
         * @param {number} [priceLte] &lt;&#x3D;
         * @param {number} [priceLt] &lt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productListGet(name?: string, limit?: number, sellerId?: string, category?: string, page?: number, order?: string, priceGte?: number, priceGt?: number, priceLte?: number, priceLt?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productListGet(name, limit, sellerId, category, page, order, priceGte, priceGt, priceLte, priceLt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get product by slug
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productSlugGet(slug: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productSlugGet(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * Get all categories from database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryAllGet(options?: any): AxiosPromise<CategoriesResponse> {
            return localVarFp.categoryAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get products follow by sellerId or not combine with category name
         * @param {string} [categoryName] search products by categoryName
         * @param {number} [limit] The numbers of items to return
         * @param {string} [sellerId] search products by seller id
         * @param {number} [page] the current page of web site
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productCategorySearchGet(categoryName?: string, limit?: number, sellerId?: string, page?: number, options?: any): AxiosPromise<ProductsResponse> {
            return localVarFp.productCategorySearchGet(categoryName, limit, sellerId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Get products follow by filter that it get from url,example - /products?sellerId=sellerId&price[gt]=2000
         * @param {string} [name] search products by name
         * @param {number} [limit] The numbers of items to return
         * @param {string} [sellerId] search products by seller id
         * @param {string} [category] search products by category id
         * @param {number} [page] the current page of web site
         * @param {string} [order] 
         * @param {number} [priceGte] find products that it &gt;&#x3D; the price inputted
         * @param {number} [priceGt] 
         * @param {number} [priceLte] &lt;&#x3D;
         * @param {number} [priceLt] &lt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productListGet(name?: string, limit?: number, sellerId?: string, category?: string, page?: number, order?: string, priceGte?: number, priceGt?: number, priceLte?: number, priceLt?: number, options?: any): AxiosPromise<ProductsResponse> {
            return localVarFp.productListGet(name, limit, sellerId, category, page, order, priceGte, priceGt, priceLte, priceLt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get product by slug
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productSlugGet(slug: string, options?: any): AxiosPromise<ProductDetailsResponse> {
            return localVarFp.productSlugGet(slug, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * Get all categories from database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public categoryAllGet(options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).categoryAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get products follow by sellerId or not combine with category name
     * @param {string} [categoryName] search products by categoryName
     * @param {number} [limit] The numbers of items to return
     * @param {string} [sellerId] search products by seller id
     * @param {number} [page] the current page of web site
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productCategorySearchGet(categoryName?: string, limit?: number, sellerId?: string, page?: number, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productCategorySearchGet(categoryName, limit, sellerId, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get products follow by filter that it get from url,example - /products?sellerId=sellerId&price[gt]=2000
     * @param {string} [name] search products by name
     * @param {number} [limit] The numbers of items to return
     * @param {string} [sellerId] search products by seller id
     * @param {string} [category] search products by category id
     * @param {number} [page] the current page of web site
     * @param {string} [order] 
     * @param {number} [priceGte] find products that it &gt;&#x3D; the price inputted
     * @param {number} [priceGt] 
     * @param {number} [priceLte] &lt;&#x3D;
     * @param {number} [priceLt] &lt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productListGet(name?: string, limit?: number, sellerId?: string, category?: string, page?: number, order?: string, priceGte?: number, priceGt?: number, priceLte?: number, priceLt?: number, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productListGet(name, limit, sellerId, category, page, order, priceGte, priceGt, priceLte, priceLt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get product by slug
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productSlugGet(slug: string, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SellerApi - axios parameter creator
 * @export
 */
export const SellerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * update status of order
         * @param {CancelOrderRequest} [cancelOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderSellerCancelPut: async (cancelOrderRequest?: CancelOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/seller/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API get all orders that done
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderSellerDoneGet: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/seller/done`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API get all orders that it not done
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderSellerNotDoneGet: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/seller/not-done`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update status of order
         * @param {UpdateStatusOrderRequest} [updateStatusOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderSellerUpdateStatusPut: async (updateStatusOrderRequest?: UpdateStatusOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/seller/update-status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStatusOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add product
         * @param {AddProductRequest} [addProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productAddPost: async (addProductRequest?: AddProductRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productDeleteIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productDeleteIdDelete', 'id', id)
            const localVarPath = `/product/delete/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update product by seller
         * @param {string} [slug] 
         * @param {AddProductRequest} [addProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUpdatePut: async (slug?: string, addProductRequest?: AddProductRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SellerApi - functional programming interface
 * @export
 */
export const SellerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SellerApiAxiosParamCreator(configuration)
    return {
        /**
         * update status of order
         * @param {CancelOrderRequest} [cancelOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderSellerCancelPut(cancelOrderRequest?: CancelOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderSellerCancelPut(cancelOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API get all orders that done
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderSellerDoneGet(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderSellerDoneGet(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API get all orders that it not done
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderSellerNotDoneGet(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderSellerNotDoneGet(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update status of order
         * @param {UpdateStatusOrderRequest} [updateStatusOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderSellerUpdateStatusPut(updateStatusOrderRequest?: UpdateStatusOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderSellerUpdateStatusPut(updateStatusOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add product
         * @param {AddProductRequest} [addProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productAddPost(addProductRequest?: AddProductRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productAddPost(addProductRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productDeleteIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productDeleteIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update product by seller
         * @param {string} [slug] 
         * @param {AddProductRequest} [addProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productUpdatePut(slug?: string, addProductRequest?: AddProductRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productUpdatePut(slug, addProductRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SellerApi - factory interface
 * @export
 */
export const SellerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SellerApiFp(configuration)
    return {
        /**
         * update status of order
         * @param {CancelOrderRequest} [cancelOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderSellerCancelPut(cancelOrderRequest?: CancelOrderRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.orderSellerCancelPut(cancelOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API get all orders that done
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderSellerDoneGet(page?: number, limit?: number, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.orderSellerDoneGet(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * API get all orders that it not done
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderSellerNotDoneGet(page?: number, limit?: number, options?: any): AxiosPromise<OrderList> {
            return localVarFp.orderSellerNotDoneGet(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * update status of order
         * @param {UpdateStatusOrderRequest} [updateStatusOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderSellerUpdateStatusPut(updateStatusOrderRequest?: UpdateStatusOrderRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.orderSellerUpdateStatusPut(updateStatusOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Add product
         * @param {AddProductRequest} [addProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productAddPost(addProductRequest?: AddProductRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.productAddPost(addProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productDeleteIdDelete(id: string, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.productDeleteIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * update product by seller
         * @param {string} [slug] 
         * @param {AddProductRequest} [addProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productUpdatePut(slug?: string, addProductRequest?: AddProductRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.productUpdatePut(slug, addProductRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SellerApi - object-oriented interface
 * @export
 * @class SellerApi
 * @extends {BaseAPI}
 */
export class SellerApi extends BaseAPI {
    /**
     * update status of order
     * @param {CancelOrderRequest} [cancelOrderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerApi
     */
    public orderSellerCancelPut(cancelOrderRequest?: CancelOrderRequest, options?: AxiosRequestConfig) {
        return SellerApiFp(this.configuration).orderSellerCancelPut(cancelOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API get all orders that done
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerApi
     */
    public orderSellerDoneGet(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return SellerApiFp(this.configuration).orderSellerDoneGet(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API get all orders that it not done
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerApi
     */
    public orderSellerNotDoneGet(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return SellerApiFp(this.configuration).orderSellerNotDoneGet(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update status of order
     * @param {UpdateStatusOrderRequest} [updateStatusOrderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerApi
     */
    public orderSellerUpdateStatusPut(updateStatusOrderRequest?: UpdateStatusOrderRequest, options?: AxiosRequestConfig) {
        return SellerApiFp(this.configuration).orderSellerUpdateStatusPut(updateStatusOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add product
     * @param {AddProductRequest} [addProductRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerApi
     */
    public productAddPost(addProductRequest?: AddProductRequest, options?: AxiosRequestConfig) {
        return SellerApiFp(this.configuration).productAddPost(addProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerApi
     */
    public productDeleteIdDelete(id: string, options?: AxiosRequestConfig) {
        return SellerApiFp(this.configuration).productDeleteIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update product by seller
     * @param {string} [slug] 
     * @param {AddProductRequest} [addProductRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerApi
     */
    public productUpdatePut(slug?: string, addProductRequest?: AddProductRequest, options?: AxiosRequestConfig) {
        return SellerApiFp(this.configuration).productUpdatePut(slug, addProductRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ShipperApi - axios parameter creator
 * @export
 */
export const ShipperApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * cancel of order
         * @param {CancelOrderRequest} [cancelOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderShipperCancelOrderPut: async (cancelOrderRequest?: CancelOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/shipper/cancel-order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API get all orders of shipper
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderShipperGetOrderGet: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/shipper/get-order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * reject of order by user
         * @param {CancelOrderRequest} [cancelOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderShipperRejectOrderPut: async (cancelOrderRequest?: CancelOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/shipper/reject-order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update status of order
         * @param {UpdateStatusOrderRequest} [updateStatusOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderShipperUpdateOrderPut: async (updateStatusOrderRequest?: UpdateStatusOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/shipper/update-order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStatusOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ShipperApi - functional programming interface
 * @export
 */
export const ShipperApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ShipperApiAxiosParamCreator(configuration)
    return {
        /**
         * cancel of order
         * @param {CancelOrderRequest} [cancelOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderShipperCancelOrderPut(cancelOrderRequest?: CancelOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderShipperCancelOrderPut(cancelOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API get all orders of shipper
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderShipperGetOrderGet(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderListShipping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderShipperGetOrderGet(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * reject of order by user
         * @param {CancelOrderRequest} [cancelOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderShipperRejectOrderPut(cancelOrderRequest?: CancelOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderShipperRejectOrderPut(cancelOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update status of order
         * @param {UpdateStatusOrderRequest} [updateStatusOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderShipperUpdateOrderPut(updateStatusOrderRequest?: UpdateStatusOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderShipperUpdateOrderPut(updateStatusOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ShipperApi - factory interface
 * @export
 */
export const ShipperApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ShipperApiFp(configuration)
    return {
        /**
         * cancel of order
         * @param {CancelOrderRequest} [cancelOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderShipperCancelOrderPut(cancelOrderRequest?: CancelOrderRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.orderShipperCancelOrderPut(cancelOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API get all orders of shipper
         * @param {number} [page] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderShipperGetOrderGet(page?: number, limit?: number, options?: any): AxiosPromise<OrderListShipping> {
            return localVarFp.orderShipperGetOrderGet(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * reject of order by user
         * @param {CancelOrderRequest} [cancelOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderShipperRejectOrderPut(cancelOrderRequest?: CancelOrderRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.orderShipperRejectOrderPut(cancelOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * update status of order
         * @param {UpdateStatusOrderRequest} [updateStatusOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderShipperUpdateOrderPut(updateStatusOrderRequest?: UpdateStatusOrderRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.orderShipperUpdateOrderPut(updateStatusOrderRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ShipperApi - object-oriented interface
 * @export
 * @class ShipperApi
 * @extends {BaseAPI}
 */
export class ShipperApi extends BaseAPI {
    /**
     * cancel of order
     * @param {CancelOrderRequest} [cancelOrderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipperApi
     */
    public orderShipperCancelOrderPut(cancelOrderRequest?: CancelOrderRequest, options?: AxiosRequestConfig) {
        return ShipperApiFp(this.configuration).orderShipperCancelOrderPut(cancelOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API get all orders of shipper
     * @param {number} [page] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipperApi
     */
    public orderShipperGetOrderGet(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return ShipperApiFp(this.configuration).orderShipperGetOrderGet(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * reject of order by user
     * @param {CancelOrderRequest} [cancelOrderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipperApi
     */
    public orderShipperRejectOrderPut(cancelOrderRequest?: CancelOrderRequest, options?: AxiosRequestConfig) {
        return ShipperApiFp(this.configuration).orderShipperRejectOrderPut(cancelOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update status of order
     * @param {UpdateStatusOrderRequest} [updateStatusOrderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ShipperApi
     */
    public orderShipperUpdateOrderPut(updateStatusOrderRequest?: UpdateStatusOrderRequest, options?: AxiosRequestConfig) {
        return ShipperApiFp(this.configuration).orderShipperUpdateOrderPut(updateStatusOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


