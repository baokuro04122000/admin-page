/* tslint:disable */
/* eslint-disable */
/**
 * BT API document
 * This is a BT API document
 *
 * The version of the OpenAPI document: 1.0.1
 * Contact: baotrandinh100@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddProductRequest
 */
export interface AddProductRequest {
    /**
     * 
     * @type {string}
     * @memberof AddProductRequest
     */
    'sellerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddProductRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AddProductRequest
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof AddProductRequest
     */
    'publisher': string;
    /**
     * 
     * @type {string}
     * @memberof AddProductRequest
     */
    'language': string;
    /**
     * 
     * @type {string}
     * @memberof AddProductRequest
     */
    'category': string;
    /**
     * 
     * @type {string}
     * @memberof AddProductRequest
     */
    'publicationDate': string;
    /**
     * 
     * @type {number}
     * @memberof AddProductRequest
     */
    'quantity': number;
    /**
     * 
     * @type {string}
     * @memberof AddProductRequest
     */
    'city': string;
    /**
     * 
     * @type {Array<FileInfo>}
     * @memberof AddProductRequest
     */
    'productPictures'?: Array<FileInfo>;
    /**
     * 
     * @type {string}
     * @memberof AddProductRequest
     */
    'summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddProductRequest
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof AddProductRequest
     */
    'discountPercent'?: number;
    /**
     * 
     * @type {number}
     * @memberof AddProductRequest
     */
    'printLength'?: number;
    /**
     * 
     * @type {number}
     * @memberof AddProductRequest
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface AnnouceSuccess
 */
export interface AnnouceSuccess {
    /**
     * 
     * @type {number}
     * @memberof AnnouceSuccess
     */
    'status'?: number;
    /**
     * 
     * @type {AnnouceSuccessData}
     * @memberof AnnouceSuccess
     */
    'data'?: AnnouceSuccessData;
}
/**
 * 
 * @export
 * @interface AnnouceSuccessAuth
 */
export interface AnnouceSuccessAuth {
    /**
     * 
     * @type {AnnouceSuccessData}
     * @memberof AnnouceSuccessAuth
     */
    'data'?: AnnouceSuccessData;
    /**
     * it use to validate with backend
     * @type {string}
     * @memberof AnnouceSuccessAuth
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface AnnouceSuccessData
 */
export interface AnnouceSuccessData {
    /**
     * 
     * @type {string}
     * @memberof AnnouceSuccessData
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface CategoriesResponse
 */
export interface CategoriesResponse {
    /**
     * 
     * @type {Array<CategoriesResponseDataInner>}
     * @memberof CategoriesResponse
     */
    'data'?: Array<CategoriesResponseDataInner>;
}
/**
 * 
 * @export
 * @interface CategoriesResponseDataInner
 */
export interface CategoriesResponseDataInner {
    /**
     * 
     * @type {string}
     * @memberof CategoriesResponseDataInner
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoriesResponseDataInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoriesResponseDataInner
     */
    'categoryImage'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoriesResponseDataInner
     */
    '_id'?: string;
}
/**
 * 
 * @export
 * @interface CategoryInfo
 */
export interface CategoryInfo {
    /**
     * 
     * @type {string}
     * @memberof CategoryInfo
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryInfo
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryInfo
     */
    'categoryImage'?: string;
}
/**
 * 
 * @export
 * @interface CategoryRequest
 */
export interface CategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof CategoryRequest
     */
    'name': string;
}
/**
 * API to save a list of photos to delete
 * @export
 * @interface DeleteImagesRequest
 */
export interface DeleteImagesRequest {
    /**
     * the field that it is unique
     * @type {string}
     * @memberof DeleteImagesRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DeleteImagesRequest
     */
    'token'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteImagesRequest
     */
    'fileList'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EditProductRequest
 */
export interface EditProductRequest {
    /**
     * 
     * @type {AddProductRequest}
     * @memberof EditProductRequest
     */
    'product'?: AddProductRequest;
    /**
     * 
     * @type {string}
     * @memberof EditProductRequest
     */
    'slug'?: string;
}
/**
 * 
 * @export
 * @interface EditQuickProductRequest
 */
export interface EditQuickProductRequest {
    /**
     * 
     * @type {string}
     * @memberof EditQuickProductRequest
     */
    'productId'?: string;
    /**
     * 
     * @type {EditQuickProductRequestProductChanged}
     * @memberof EditQuickProductRequest
     */
    'productChanged'?: EditQuickProductRequestProductChanged;
}
/**
 * 
 * @export
 * @interface EditQuickProductRequestProductChanged
 */
export interface EditQuickProductRequestProductChanged {
    /**
     * 
     * @type {string}
     * @memberof EditQuickProductRequestProductChanged
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EditQuickProductRequestProductChanged
     */
    'author': string;
    /**
     * 
     * @type {string}
     * @memberof EditQuickProductRequestProductChanged
     */
    'summary': string;
    /**
     * 
     * @type {number}
     * @memberof EditQuickProductRequestProductChanged
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof EditQuickProductRequestProductChanged
     */
    'discountPercent': number;
    /**
     * 
     * @type {number}
     * @memberof EditQuickProductRequestProductChanged
     */
    'quantity': number;
}
/**
 * Error responses are sent when an error (e.g. unauthorized, bad request) occurred.
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * the status of response.
     * @type {number}
     * @memberof ErrorResponse
     */
    'status'?: number;
    /**
     * 
     * @type {ErrorResponseErrors}
     * @memberof ErrorResponse
     */
    'errors'?: ErrorResponseErrors;
}
/**
 * 
 * @export
 * @interface ErrorResponseErrors
 */
export interface ErrorResponseErrors {
    /**
     * 
     * @type {string}
     * @memberof ErrorResponseErrors
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface FileInfo
 */
export interface FileInfo {
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'fileLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof FileInfo
     */
    'fileId'?: string;
}
/**
 * 
 * @export
 * @interface ForgotPassword
 */
export interface ForgotPassword {
    /**
     * 
     * @type {string}
     * @memberof ForgotPassword
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface ForgotPasswordRequest
 */
export interface ForgotPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ForgotPasswordRequest
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface MetaProduct
 */
export interface MetaProduct {
    /**
     * 
     * @type {number}
     * @memberof MetaProduct
     */
    'totalSold'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaProduct
     */
    'totalOrder'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaProduct
     */
    'totalReview'?: number;
}
/**
 * some information that it relate the shop of seller
 * @export
 * @interface MetaSeller
 */
export interface MetaSeller {
    /**
     * 
     * @type {number}
     * @memberof MetaSeller
     */
    'totalSole'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaSeller
     */
    'totalProduct'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaSeller
     */
    'totalEvaluation'?: number;
    /**
     * 
     * @type {number}
     * @memberof MetaSeller
     */
    'ranking'?: number;
    /**
     * 
     * @type {string}
     * @memberof MetaSeller
     */
    'title'?: string;
}
/**
 * OTP got from your email
 * @export
 * @interface OTPRequest
 */
export interface OTPRequest {
    /**
     * 
     * @type {number}
     * @memberof OTPRequest
     */
    'otp': number;
    /**
     * 
     * @type {string}
     * @memberof OTPRequest
     */
    'userId'?: string;
}
/**
 * OTP got from your email
 * @export
 * @interface OTPRequestActive
 */
export interface OTPRequestActive {
    /**
     * 
     * @type {string}
     * @memberof OTPRequestActive
     */
    'userId': string;
    /**
     * 
     * @type {number}
     * @memberof OTPRequestActive
     */
    'otp': number;
}
/**
 * 
 * @export
 * @interface OTPResponse
 */
export interface OTPResponse {
    /**
     * 
     * @type {OTPResponseData}
     * @memberof OTPResponse
     */
    'data'?: OTPResponseData;
    /**
     * 
     * @type {string}
     * @memberof OTPResponse
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface OTPResponseData
 */
export interface OTPResponseData {
    /**
     * 
     * @type {string}
     * @memberof OTPResponseData
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface OrderDetails
 */
export interface OrderDetails {
    /**
     * 
     * @type {string}
     * @memberof OrderDetails
     */
    '_id'?: string;
    /**
     * 
     * @type {OrderDetailsUser}
     * @memberof OrderDetails
     */
    'user'?: OrderDetailsUser;
    /**
     * 
     * @type {OrderDetailsAddress}
     * @memberof OrderDetails
     */
    'address'?: OrderDetailsAddress;
    /**
     * 
     * @type {string}
     * @memberof OrderDetails
     */
    'paymentType'?: string;
    /**
     * 
     * @type {Array<OrderDetailsItemsInner>}
     * @memberof OrderDetails
     */
    'items'?: Array<OrderDetailsItemsInner>;
    /**
     * 
     * @type {OrderDetailsProduct}
     * @memberof OrderDetails
     */
    'product'?: OrderDetailsProduct;
}
/**
 * 
 * @export
 * @interface OrderDetailsAddress
 */
export interface OrderDetailsAddress {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsAddress
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsAddress
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsAddress
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsAddress
     */
    'zipCode'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDetailsAddress
     */
    'isDefault'?: boolean;
}
/**
 * 
 * @export
 * @interface OrderDetailsItemsInner
 */
export interface OrderDetailsItemsInner {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsItemsInner
     */
    'product'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsItemsInner
     */
    'shippingCode'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsItemsInner
     */
    'discount'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsItemsInner
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsItemsInner
     */
    'totalPaid'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsItemsInner
     */
    'quantity'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsItemsInner
     */
    'shippingCost'?: number;
    /**
     * 
     * @type {Array<OrderDetailsItemsInnerOrderStatusInner>}
     * @memberof OrderDetailsItemsInner
     */
    'orderStatus'?: Array<OrderDetailsItemsInnerOrderStatusInner>;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsItemsInner
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsItemsInner
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsItemsInner
     */
    '_id'?: string;
}
/**
 * 
 * @export
 * @interface OrderDetailsItemsInnerOrderStatusInner
 */
export interface OrderDetailsItemsInnerOrderStatusInner {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsItemsInnerOrderStatusInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsItemsInnerOrderStatusInner
     */
    'date'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrderDetailsItemsInnerOrderStatusInner
     */
    'isCompleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsItemsInnerOrderStatusInner
     */
    '_id'?: string;
}
/**
 * 
 * @export
 * @interface OrderDetailsProduct
 */
export interface OrderDetailsProduct {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsProduct
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsProduct
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsProduct
     */
    'quantity'?: number;
    /**
     * 
     * @type {Array<OrderDetailsProductProductPicturesInner>}
     * @memberof OrderDetailsProduct
     */
    'productPictures'?: Array<OrderDetailsProductProductPicturesInner>;
    /**
     * 
     * @type {OrderDetailsUserMeta}
     * @memberof OrderDetailsProduct
     */
    'meta'?: OrderDetailsUserMeta;
}
/**
 * 
 * @export
 * @interface OrderDetailsProductProductPicturesInner
 */
export interface OrderDetailsProductProductPicturesInner {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsProductProductPicturesInner
     */
    'fileId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsProductProductPicturesInner
     */
    'fileLink'?: string;
}
/**
 * 
 * @export
 * @interface OrderDetailsUser
 */
export interface OrderDetailsUser {
    /**
     * 
     * @type {OrderDetailsUserInfo}
     * @memberof OrderDetailsUser
     */
    'info'?: OrderDetailsUserInfo;
    /**
     * 
     * @type {OrderDetailsUserMeta}
     * @memberof OrderDetailsUser
     */
    'meta'?: OrderDetailsUserMeta;
}
/**
 * 
 * @export
 * @interface OrderDetailsUserInfo
 */
export interface OrderDetailsUserInfo {
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsUserInfo
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsUserInfo
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsUserInfo
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsUserInfo
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderDetailsUserInfo
     */
    'birthDay'?: string;
}
/**
 * 
 * @export
 * @interface OrderDetailsUserMeta
 */
export interface OrderDetailsUserMeta {
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsUserMeta
     */
    'totalBuy'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderDetailsUserMeta
     */
    'totalCancel'?: number;
}
/**
 * 
 * @export
 * @interface OrderList
 */
export interface OrderList {
    /**
     * 
     * @type {number}
     * @memberof OrderList
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderList
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderList
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderList
     */
    'total_page'?: number;
    /**
     * 
     * @type {Array<OrderDetails>}
     * @memberof OrderList
     */
    'data'?: Array<OrderDetails>;
}
/**
 * 
 * @export
 * @interface ProductDetails
 */
export interface ProductDetails {
    /**
     * 
     * @type {string}
     * @memberof ProductDetails
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDetails
     */
    'name'?: string;
    /**
     * 
     * @type {SellerDetail}
     * @memberof ProductDetails
     */
    'seller'?: SellerDetail;
    /**
     * 
     * @type {string}
     * @memberof ProductDetails
     */
    'slug'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductDetails
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductDetails
     */
    'discountPercent'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductDetails
     */
    'summary'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDetails
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProductDetails
     */
    'quantity'?: number;
    /**
     * 
     * @type {Array<FileInfo>}
     * @memberof ProductDetails
     */
    'productPictures'?: Array<FileInfo>;
    /**
     * 
     * @type {CategoryInfo}
     * @memberof ProductDetails
     */
    'category'?: CategoryInfo;
    /**
     * 
     * @type {SpecsProduct}
     * @memberof ProductDetails
     */
    'specs'?: SpecsProduct;
    /**
     * 
     * @type {MetaProduct}
     * @memberof ProductDetails
     */
    'meta'?: MetaProduct;
}
/**
 * 
 * @export
 * @interface ProductDetailsResponse
 */
export interface ProductDetailsResponse {
    /**
     * 
     * @type {ProductDetails}
     * @memberof ProductDetailsResponse
     */
    'data'?: ProductDetails;
}
/**
 * 
 * @export
 * @interface ProductsResponse
 */
export interface ProductsResponse {
    /**
     * 
     * @type {Array<ProductDetails>}
     * @memberof ProductsResponse
     */
    'data'?: Array<ProductDetails>;
    /**
     * 
     * @type {number}
     * @memberof ProductsResponse
     */
    'totalProduct'?: number;
}
/**
 * 
 * @export
 * @interface ResetPasswordRequest
 */
export interface ResetPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResetPasswordRequest
     */
    'userId'?: string;
}
/**
 * Seller detail information
 * @export
 * @interface SellerDetail
 */
export interface SellerDetail {
    /**
     * 
     * @type {string}
     * @memberof SellerDetail
     */
    '_id'?: string;
    /**
     * 
     * @type {SellerDetailInfo}
     * @memberof SellerDetail
     */
    'info'?: SellerDetailInfo;
    /**
     * 
     * @type {SellerDetailLogo}
     * @memberof SellerDetail
     */
    'logo'?: SellerDetailLogo;
    /**
     * 
     * @type {string}
     * @memberof SellerDetail
     */
    'slogan'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerDetail
     */
    'type'?: string;
    /**
     * 
     * @type {MetaSeller}
     * @memberof SellerDetail
     */
    'meta'?: MetaSeller;
    /**
     * to implement lock the account of seller
     * @type {boolean}
     * @memberof SellerDetail
     */
    'isDisable'?: boolean;
}
/**
 * 
 * @export
 * @interface SellerDetailInfo
 */
export interface SellerDetailInfo {
    /**
     * 
     * @type {string}
     * @memberof SellerDetailInfo
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SellerDetailInfo
     */
    'address'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SellerDetailInfo
     */
    'phone'?: string;
}
/**
 * 
 * @export
 * @interface SellerDetailLogo
 */
export interface SellerDetailLogo {
    /**
     * 
     * @type {string}
     * @memberof SellerDetailLogo
     */
    'fileLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerDetailLogo
     */
    'fileId'?: string;
}
/**
 * the info of seller will send to server to create a seller account
 * @export
 * @interface SellerRegisterRequest
 */
export interface SellerRegisterRequest {
    /**
     * check role
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'fbLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'inLink'?: string;
    /**
     * name is unique
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'slogan': string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequest
     */
    'phone': string;
    /**
     * 
     * @type {SellerRegisterRequestLogo}
     * @memberof SellerRegisterRequest
     */
    'logo'?: SellerRegisterRequestLogo;
    /**
     * It help the seller confirm the Genuine Store
     * @type {Array<FileInfo>}
     * @memberof SellerRegisterRequest
     */
    'proof'?: Array<FileInfo>;
}
/**
 * The logo of shop
 * @export
 * @interface SellerRegisterRequestLogo
 */
export interface SellerRegisterRequestLogo {
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequestLogo
     */
    'fileLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof SellerRegisterRequestLogo
     */
    'fileId'?: string;
}
/**
 * 
 * @export
 * @interface SendOTPAgain
 */
export interface SendOTPAgain {
    /**
     * 
     * @type {string}
     * @memberof SendOTPAgain
     */
    'userId'?: string;
}
/**
 * 
 * @export
 * @interface SpecsProduct
 */
export interface SpecsProduct {
    /**
     * 
     * @type {string}
     * @memberof SpecsProduct
     */
    'author'?: string;
    /**
     * 
     * @type {number}
     * @memberof SpecsProduct
     */
    'printLength'?: number;
    /**
     * 
     * @type {string}
     * @memberof SpecsProduct
     */
    'publisher'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecsProduct
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecsProduct
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecsProduct
     */
    'publicationDate'?: string;
}
/**
 * 
 * @export
 * @interface UpdateStatusOrderRequest
 */
export interface UpdateStatusOrderRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateStatusOrderRequest
     */
    'orderId'?: string;
}
/**
 * 
 * @export
 * @interface UserCredentialResponse
 */
export interface UserCredentialResponse {
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {UserCredentialResponseData}
     * @memberof UserCredentialResponse
     */
    'data'?: UserCredentialResponseData;
}
/**
 * 
 * @export
 * @interface UserCredentialResponseData
 */
export interface UserCredentialResponseData {
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    '_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'nickName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'role'?: string;
    /**
     * 
     * @type {FileInfo}
     * @memberof UserCredentialResponseData
     */
    'profilePicture'?: FileInfo;
    /**
     * 
     * @type {UserCredentialResponseDataMeta}
     * @memberof UserCredentialResponseData
     */
    'meta'?: UserCredentialResponseDataMeta;
    /**
     * 
     * @type {string}
     * @memberof UserCredentialResponseData
     */
    'typeLogin'?: string;
    /**
     * 
     * @type {SellerDetail}
     * @memberof UserCredentialResponseData
     */
    'seller'?: SellerDetail;
}
/**
 * 
 * @export
 * @interface UserCredentialResponseDataMeta
 */
export interface UserCredentialResponseDataMeta {
    /**
     * 
     * @type {number}
     * @memberof UserCredentialResponseDataMeta
     */
    'totalBuy'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserCredentialResponseDataMeta
     */
    'totalCancel'?: number;
}
/**
 * 
 * @export
 * @interface UserCredentials
 */
export interface UserCredentials {
    /**
     * 
     * @type {string}
     * @memberof UserCredentials
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCredentials
     */
    'password': string;
}
/**
 * user detail information
 * @export
 * @interface UserDetail
 */
export interface UserDetail {
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'name'?: string;
    /**
     * 
     * @type {UserDetailMeta}
     * @memberof UserDetail
     */
    'meta'?: UserDetailMeta;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDetail
     */
    'updatedAt'?: string;
}
/**
 * 
 * @export
 * @interface UserDetailMeta
 */
export interface UserDetailMeta {
    /**
     * 
     * @type {number}
     * @memberof UserDetailMeta
     */
    'totalBuy'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserDetailMeta
     */
    'totalCancel'?: string;
}
/**
 * 
 * @export
 * @interface UserMobileRegister
 */
export interface UserMobileRegister {
    /**
     * 
     * @type {string}
     * @memberof UserMobileRegister
     */
    'email': string;
    /**
     * Password must be 8-16 characters and contain both numbers and letters characters
     * @type {string}
     * @memberof UserMobileRegister
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserMobileRegister
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserMobileRegister
     */
    'lastName': string;
    /**
     * it kind of a checkbok
     * @type {string}
     * @memberof UserMobileRegister
     */
    'gender': string;
}
/**
 * 
 * @export
 * @interface UserRegister
 */
export interface UserRegister {
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'email': string;
    /**
     * Password must be 8-16 characters and contain both numbers and letters characters
     * @type {string}
     * @memberof UserRegister
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserRegister
     */
    'lastName': string;
    /**
     * it kind of a checkbok
     * @type {string}
     * @memberof UserRegister
     */
    'gender': string;
}
/**
 * 
 * @export
 * @interface UserRequestSignUpSeller
 */
export interface UserRequestSignUpSeller {
    /**
     * 
     * @type {string}
     * @memberof UserRequestSignUpSeller
     */
    'token': string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a category from admin
         * @param {CategoryRequest} [categoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAddCategoryPost: async (categoryRequest?: CategoryRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/add-category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a category from admin
         * @param {CategoryRequest} [categoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminAddCategoryPost(categoryRequest?: CategoryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminAddCategoryPost(categoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Add a category from admin
         * @param {CategoryRequest} [categoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminAddCategoryPost(categoryRequest?: CategoryRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.adminAddCategoryPost(categoryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Add a category from admin
     * @param {CategoryRequest} [categoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public adminAddCategoryPost(categoryRequest?: CategoryRequest, options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).adminAddCategoryPost(categoryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get user when login by google successfully
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Login by google account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOauthGoogleGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/oauth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check the token is valid to access the seller register page
         * @param {UserRequestSignUpSeller} [userRequestSignUpSeller] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCheckSellerRegisterRequestPost: async (userRequestSignUpSeller?: UserRequestSignUpSeller, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/check-seller-register-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRequestSignUpSeller, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete file by token
         * @param {DeleteImagesRequest} [deleteImagesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDeleteFilesPost: async (deleteImagesRequest?: DeleteImagesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/delete-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteImagesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send mail to reset password - step 1
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailResetPasswordPost: async (forgotPasswordRequest?: ForgotPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/email-reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Login by Email and Password 
         * @param {UserCredentials} [userCredentials] email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost: async (userCredentials?: UserCredentials, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCredentials, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can only log themselves out, not other users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User sign up an local account - spend for mobile
         * @param {UserMobileRegister} [userMobileRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMobileRegisterPost: async (userMobileRegister?: UserMobileRegister, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/mobile-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userMobileRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User active account that it just created - mobile
         * @param {OTPRequestActive} [oTPRequestActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOtpRegisterPost: async (oTPRequestActive?: OTPRequestActive, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/otp-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oTPRequestActive, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * OTP matched then server will send for you verify token to reset password - step 2
         * @param {OTPRequest} [oTPRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOtpResetPasswordPost: async (oTPRequest?: OTPRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/otp-reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(oTPRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh token when access token is expired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshTokenGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User sign up an local account
         * @param {UserRegister} [userRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost: async (userRegister?: UserRegister, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userRegister, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request send otp again
         * @param {SendOTPAgain} [sendOTPAgain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterSendOtpAgainPost: async (sendOTPAgain?: SendOTPAgain, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/register/send-otp-again`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendOTPAgain, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reset password follow by verify token - final step
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordPost: async (resetPasswordRequest?: ResetPasswordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API seller register account
         * @param {SellerRegisterRequest} [sellerRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerRegisterPost: async (sellerRegisterRequest?: SellerRegisterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/seller-register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sellerRegisterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User sign up seller account by token and this user need to sign in before
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerRegisterRequestGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/seller-register-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Get user when login by google successfully
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMeGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredentialResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMeGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Login by google account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiOauthGoogleGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiOauthGoogleGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check the token is valid to access the seller register page
         * @param {UserRequestSignUpSeller} [userRequestSignUpSeller] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authCheckSellerRegisterRequestPost(userRequestSignUpSeller?: UserRequestSignUpSeller, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCheckSellerRegisterRequestPost(userRequestSignUpSeller, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete file by token
         * @param {DeleteImagesRequest} [deleteImagesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDeleteFilesPost(deleteImagesRequest?: DeleteImagesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDeleteFilesPost(deleteImagesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Send mail to reset password - step 1
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authEmailResetPasswordPost(forgotPasswordRequest?: ForgotPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccessAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authEmailResetPasswordPost(forgotPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Login by Email and Password 
         * @param {UserCredentials} [userCredentials] email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLoginPost(userCredentials?: UserCredentials, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredentialResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLoginPost(userCredentials, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Users can only log themselves out, not other users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authLogoutGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authLogoutGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User sign up an local account - spend for mobile
         * @param {UserMobileRegister} [userMobileRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authMobileRegisterPost(userMobileRegister?: UserMobileRegister, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccessAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authMobileRegisterPost(userMobileRegister, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User active account that it just created - mobile
         * @param {OTPRequestActive} [oTPRequestActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOtpRegisterPost(oTPRequestActive?: OTPRequestActive, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOtpRegisterPost(oTPRequestActive, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * OTP matched then server will send for you verify token to reset password - step 2
         * @param {OTPRequest} [oTPRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOtpResetPasswordPost(oTPRequest?: OTPRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OTPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOtpResetPasswordPost(oTPRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Refresh token when access token is expired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRefreshTokenGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredentialResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefreshTokenGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User sign up an local account
         * @param {UserRegister} [userRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterPost(userRegister?: UserRegister, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterPost(userRegister, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Request send otp again
         * @param {SendOTPAgain} [sendOTPAgain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRegisterSendOtpAgainPost(sendOTPAgain?: SendOTPAgain, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccessAuth>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRegisterSendOtpAgainPost(sendOTPAgain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Reset password follow by verify token - final step
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authResetPasswordPost(resetPasswordRequest?: ResetPasswordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authResetPasswordPost(resetPasswordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API seller register account
         * @param {SellerRegisterRequest} [sellerRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSellerRegisterPost(sellerRegisterRequest?: SellerRegisterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSellerRegisterPost(sellerRegisterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User sign up seller account by token and this user need to sign in before
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSellerRegisterRequestGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSellerRegisterRequestGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Get user when login by google successfully
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMeGet(options?: any): AxiosPromise<UserCredentialResponse> {
            return localVarFp.apiMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Login by google account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiOauthGoogleGet(options?: any): AxiosPromise<void> {
            return localVarFp.apiOauthGoogleGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Check the token is valid to access the seller register page
         * @param {UserRequestSignUpSeller} [userRequestSignUpSeller] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCheckSellerRegisterRequestPost(userRequestSignUpSeller?: UserRequestSignUpSeller, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authCheckSellerRegisterRequestPost(userRequestSignUpSeller, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete file by token
         * @param {DeleteImagesRequest} [deleteImagesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDeleteFilesPost(deleteImagesRequest?: DeleteImagesRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authDeleteFilesPost(deleteImagesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Send mail to reset password - step 1
         * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authEmailResetPasswordPost(forgotPasswordRequest?: ForgotPasswordRequest, options?: any): AxiosPromise<AnnouceSuccessAuth> {
            return localVarFp.authEmailResetPasswordPost(forgotPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User Login by Email and Password 
         * @param {UserCredentials} [userCredentials] email and password
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLoginPost(userCredentials?: UserCredentials, options?: any): AxiosPromise<UserCredentialResponse> {
            return localVarFp.authLoginPost(userCredentials, options).then((request) => request(axios, basePath));
        },
        /**
         * Users can only log themselves out, not other users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authLogoutGet(options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authLogoutGet(options).then((request) => request(axios, basePath));
        },
        /**
         * User sign up an local account - spend for mobile
         * @param {UserMobileRegister} [userMobileRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authMobileRegisterPost(userMobileRegister?: UserMobileRegister, options?: any): AxiosPromise<AnnouceSuccessAuth> {
            return localVarFp.authMobileRegisterPost(userMobileRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * User active account that it just created - mobile
         * @param {OTPRequestActive} [oTPRequestActive] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOtpRegisterPost(oTPRequestActive?: OTPRequestActive, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authOtpRegisterPost(oTPRequestActive, options).then((request) => request(axios, basePath));
        },
        /**
         * OTP matched then server will send for you verify token to reset password - step 2
         * @param {OTPRequest} [oTPRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOtpResetPasswordPost(oTPRequest?: OTPRequest, options?: any): AxiosPromise<OTPResponse> {
            return localVarFp.authOtpResetPasswordPost(oTPRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh token when access token is expired
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshTokenGet(options?: any): AxiosPromise<UserCredentialResponse> {
            return localVarFp.authRefreshTokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * User sign up an local account
         * @param {UserRegister} [userRegister] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterPost(userRegister?: UserRegister, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authRegisterPost(userRegister, options).then((request) => request(axios, basePath));
        },
        /**
         * Request send otp again
         * @param {SendOTPAgain} [sendOTPAgain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRegisterSendOtpAgainPost(sendOTPAgain?: SendOTPAgain, options?: any): AxiosPromise<AnnouceSuccessAuth> {
            return localVarFp.authRegisterSendOtpAgainPost(sendOTPAgain, options).then((request) => request(axios, basePath));
        },
        /**
         * Reset password follow by verify token - final step
         * @param {ResetPasswordRequest} [resetPasswordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authResetPasswordPost(resetPasswordRequest?: ResetPasswordRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authResetPasswordPost(resetPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API seller register account
         * @param {SellerRegisterRequest} [sellerRegisterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerRegisterPost(sellerRegisterRequest?: SellerRegisterRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authSellerRegisterPost(sellerRegisterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User sign up seller account by token and this user need to sign in before
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSellerRegisterRequestGet(options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.authSellerRegisterRequestGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Get user when login by google successfully
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiMeGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Login by google account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public apiOauthGoogleGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).apiOauthGoogleGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check the token is valid to access the seller register page
     * @param {UserRequestSignUpSeller} [userRequestSignUpSeller] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authCheckSellerRegisterRequestPost(userRequestSignUpSeller?: UserRequestSignUpSeller, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authCheckSellerRegisterRequestPost(userRequestSignUpSeller, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete file by token
     * @param {DeleteImagesRequest} [deleteImagesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authDeleteFilesPost(deleteImagesRequest?: DeleteImagesRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authDeleteFilesPost(deleteImagesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send mail to reset password - step 1
     * @param {ForgotPasswordRequest} [forgotPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authEmailResetPasswordPost(forgotPasswordRequest?: ForgotPasswordRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authEmailResetPasswordPost(forgotPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Login by Email and Password 
     * @param {UserCredentials} [userCredentials] email and password
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLoginPost(userCredentials?: UserCredentials, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLoginPost(userCredentials, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Users can only log themselves out, not other users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authLogoutGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authLogoutGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User sign up an local account - spend for mobile
     * @param {UserMobileRegister} [userMobileRegister] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authMobileRegisterPost(userMobileRegister?: UserMobileRegister, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authMobileRegisterPost(userMobileRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User active account that it just created - mobile
     * @param {OTPRequestActive} [oTPRequestActive] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOtpRegisterPost(oTPRequestActive?: OTPRequestActive, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOtpRegisterPost(oTPRequestActive, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * OTP matched then server will send for you verify token to reset password - step 2
     * @param {OTPRequest} [oTPRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOtpResetPasswordPost(oTPRequest?: OTPRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOtpResetPasswordPost(oTPRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh token when access token is expired
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRefreshTokenGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRefreshTokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User sign up an local account
     * @param {UserRegister} [userRegister] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRegisterPost(userRegister?: UserRegister, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRegisterPost(userRegister, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request send otp again
     * @param {SendOTPAgain} [sendOTPAgain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRegisterSendOtpAgainPost(sendOTPAgain?: SendOTPAgain, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRegisterSendOtpAgainPost(sendOTPAgain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reset password follow by verify token - final step
     * @param {ResetPasswordRequest} [resetPasswordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authResetPasswordPost(resetPasswordRequest?: ResetPasswordRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authResetPasswordPost(resetPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API seller register account
     * @param {SellerRegisterRequest} [sellerRegisterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSellerRegisterPost(sellerRegisterRequest?: SellerRegisterRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSellerRegisterPost(sellerRegisterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User sign up seller account by token and this user need to sign in before
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSellerRegisterRequestGet(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSellerRegisterRequestGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductApi - axios parameter creator
 * @export
 */
export const ProductApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all categories from database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get product by slug
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productSlugGet: async (slug: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('productSlugGet', 'slug', slug)
            const localVarPath = `/product/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get products follow by filter that it get from url,example - /products?sellerId=sellerId&price[gt]=2000
         * @param {string} [keyword] search products by name
         * @param {number} [limit] The numbers of items to return
         * @param {string} [sellerId] search products by seller id
         * @param {string} [category] search products by category id
         * @param {number} [currentPage] the current page of web site
         * @param {number} [priceGte] find products that it &gt;&#x3D; the price inputted
         * @param {number} [priceGt] 
         * @param {number} [priceLte] &lt;&#x3D;
         * @param {number} [priceLt] &lt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet: async (keyword?: string, limit?: number, sellerId?: string, category?: string, currentPage?: number, priceGte?: number, priceGt?: number, priceLte?: number, priceLt?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (keyword !== undefined) {
                localVarQueryParameter['keyword'] = keyword;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sellerId !== undefined) {
                localVarQueryParameter['sellerId'] = sellerId;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (priceGte !== undefined) {
                localVarQueryParameter['price[gte]'] = priceGte;
            }

            if (priceGt !== undefined) {
                localVarQueryParameter['price[gt]'] = priceGt;
            }

            if (priceLte !== undefined) {
                localVarQueryParameter['price[lte]'] = priceLte;
            }

            if (priceLt !== undefined) {
                localVarQueryParameter['price[lt]'] = priceLt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all categories from database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async categoriesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoriesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.categoriesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get product by slug
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productSlugGet(slug: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productSlugGet(slug, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get products follow by filter that it get from url,example - /products?sellerId=sellerId&price[gt]=2000
         * @param {string} [keyword] search products by name
         * @param {number} [limit] The numbers of items to return
         * @param {string} [sellerId] search products by seller id
         * @param {string} [category] search products by category id
         * @param {number} [currentPage] the current page of web site
         * @param {number} [priceGte] find products that it &gt;&#x3D; the price inputted
         * @param {number} [priceGt] 
         * @param {number} [priceLte] &lt;&#x3D;
         * @param {number} [priceLt] &lt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsGet(keyword?: string, limit?: number, sellerId?: string, category?: string, currentPage?: number, priceGte?: number, priceGt?: number, priceLte?: number, priceLt?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsGet(keyword, limit, sellerId, category, currentPage, priceGte, priceGt, priceLte, priceLt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductApiFp(configuration)
    return {
        /**
         * Get all categories from database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesGet(options?: any): AxiosPromise<CategoriesResponse> {
            return localVarFp.categoriesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get product by slug
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productSlugGet(slug: string, options?: any): AxiosPromise<ProductDetailsResponse> {
            return localVarFp.productSlugGet(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Get products follow by filter that it get from url,example - /products?sellerId=sellerId&price[gt]=2000
         * @param {string} [keyword] search products by name
         * @param {number} [limit] The numbers of items to return
         * @param {string} [sellerId] search products by seller id
         * @param {string} [category] search products by category id
         * @param {number} [currentPage] the current page of web site
         * @param {number} [priceGte] find products that it &gt;&#x3D; the price inputted
         * @param {number} [priceGt] 
         * @param {number} [priceLte] &lt;&#x3D;
         * @param {number} [priceLt] &lt;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsGet(keyword?: string, limit?: number, sellerId?: string, category?: string, currentPage?: number, priceGte?: number, priceGt?: number, priceLte?: number, priceLt?: number, options?: any): AxiosPromise<ProductsResponse> {
            return localVarFp.productsGet(keyword, limit, sellerId, category, currentPage, priceGte, priceGt, priceLte, priceLt, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * Get all categories from database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public categoriesGet(options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).categoriesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get product by slug
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productSlugGet(slug: string, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productSlugGet(slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get products follow by filter that it get from url,example - /products?sellerId=sellerId&price[gt]=2000
     * @param {string} [keyword] search products by name
     * @param {number} [limit] The numbers of items to return
     * @param {string} [sellerId] search products by seller id
     * @param {string} [category] search products by category id
     * @param {number} [currentPage] the current page of web site
     * @param {number} [priceGte] find products that it &gt;&#x3D; the price inputted
     * @param {number} [priceGt] 
     * @param {number} [priceLte] &lt;&#x3D;
     * @param {number} [priceLt] &lt;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public productsGet(keyword?: string, limit?: number, sellerId?: string, category?: string, currentPage?: number, priceGte?: number, priceGt?: number, priceLte?: number, priceLt?: number, options?: AxiosRequestConfig) {
        return ProductApiFp(this.configuration).productsGet(keyword, limit, sellerId, category, currentPage, priceGte, priceGt, priceLte, priceLt, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SellerApi - axios parameter creator
 * @export
 */
export const SellerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add product
         * @param {AddProductRequest} [addProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerAddProductPost: async (addProductRequest?: AddProductRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/seller/add-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerDeleteProductIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sellerDeleteProductIdDelete', 'id', id)
            const localVarPath = `/seller/delete-product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * API get all orders that it not done
         * @param {number} [currentPage] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerOrdersProcessingGet: async (currentPage?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/seller/orders-processing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (currentPage !== undefined) {
                localVarQueryParameter['currentPage'] = currentPage;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update quick product by seller
         * @param {EditQuickProductRequest} [editQuickProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerQuickUpdateProductPut: async (editQuickProductRequest?: EditQuickProductRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/seller/quick-update-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editQuickProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update status of order
         * @param {UpdateStatusOrderRequest} [updateStatusOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerStatusOrderPut: async (updateStatusOrderRequest?: UpdateStatusOrderRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/seller/status-order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateStatusOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * update product by seller
         * @param {EditProductRequest} [editProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerUpdateProductPut: async (editProductRequest?: EditProductRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/seller/update-product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SellerApi - functional programming interface
 * @export
 */
export const SellerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SellerApiAxiosParamCreator(configuration)
    return {
        /**
         * Add product
         * @param {AddProductRequest} [addProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellerAddProductPost(addProductRequest?: AddProductRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellerAddProductPost(addProductRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellerDeleteProductIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellerDeleteProductIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * API get all orders that it not done
         * @param {number} [currentPage] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellerOrdersProcessingGet(currentPage?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellerOrdersProcessingGet(currentPage, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update quick product by seller
         * @param {EditQuickProductRequest} [editQuickProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellerQuickUpdateProductPut(editQuickProductRequest?: EditQuickProductRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellerQuickUpdateProductPut(editQuickProductRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update status of order
         * @param {UpdateStatusOrderRequest} [updateStatusOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellerStatusOrderPut(updateStatusOrderRequest?: UpdateStatusOrderRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellerStatusOrderPut(updateStatusOrderRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * update product by seller
         * @param {EditProductRequest} [editProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sellerUpdateProductPut(editProductRequest?: EditProductRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnouceSuccess>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sellerUpdateProductPut(editProductRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SellerApi - factory interface
 * @export
 */
export const SellerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SellerApiFp(configuration)
    return {
        /**
         * Add product
         * @param {AddProductRequest} [addProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerAddProductPost(addProductRequest?: AddProductRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.sellerAddProductPost(addProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerDeleteProductIdDelete(id: string, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.sellerDeleteProductIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * API get all orders that it not done
         * @param {number} [currentPage] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerOrdersProcessingGet(currentPage?: number, limit?: number, options?: any): AxiosPromise<OrderList> {
            return localVarFp.sellerOrdersProcessingGet(currentPage, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * update quick product by seller
         * @param {EditQuickProductRequest} [editQuickProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerQuickUpdateProductPut(editQuickProductRequest?: EditQuickProductRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.sellerQuickUpdateProductPut(editQuickProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * update status of order
         * @param {UpdateStatusOrderRequest} [updateStatusOrderRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerStatusOrderPut(updateStatusOrderRequest?: UpdateStatusOrderRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.sellerStatusOrderPut(updateStatusOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * update product by seller
         * @param {EditProductRequest} [editProductRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sellerUpdateProductPut(editProductRequest?: EditProductRequest, options?: any): AxiosPromise<AnnouceSuccess> {
            return localVarFp.sellerUpdateProductPut(editProductRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SellerApi - object-oriented interface
 * @export
 * @class SellerApi
 * @extends {BaseAPI}
 */
export class SellerApi extends BaseAPI {
    /**
     * Add product
     * @param {AddProductRequest} [addProductRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerApi
     */
    public sellerAddProductPost(addProductRequest?: AddProductRequest, options?: AxiosRequestConfig) {
        return SellerApiFp(this.configuration).sellerAddProductPost(addProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerApi
     */
    public sellerDeleteProductIdDelete(id: string, options?: AxiosRequestConfig) {
        return SellerApiFp(this.configuration).sellerDeleteProductIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * API get all orders that it not done
     * @param {number} [currentPage] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerApi
     */
    public sellerOrdersProcessingGet(currentPage?: number, limit?: number, options?: AxiosRequestConfig) {
        return SellerApiFp(this.configuration).sellerOrdersProcessingGet(currentPage, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update quick product by seller
     * @param {EditQuickProductRequest} [editQuickProductRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerApi
     */
    public sellerQuickUpdateProductPut(editQuickProductRequest?: EditQuickProductRequest, options?: AxiosRequestConfig) {
        return SellerApiFp(this.configuration).sellerQuickUpdateProductPut(editQuickProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update status of order
     * @param {UpdateStatusOrderRequest} [updateStatusOrderRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerApi
     */
    public sellerStatusOrderPut(updateStatusOrderRequest?: UpdateStatusOrderRequest, options?: AxiosRequestConfig) {
        return SellerApiFp(this.configuration).sellerStatusOrderPut(updateStatusOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * update product by seller
     * @param {EditProductRequest} [editProductRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SellerApi
     */
    public sellerUpdateProductPut(editProductRequest?: EditProductRequest, options?: AxiosRequestConfig) {
        return SellerApiFp(this.configuration).sellerUpdateProductPut(editProductRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


